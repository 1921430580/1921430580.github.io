<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>my blog</title>
  
  <subtitle>记录生活</subtitle>
  <link href="http://1921430580.github.io/atom.xml" rel="self"/>
  
  <link href="http://1921430580.github.io/"/>
  <updated>2022-05-09T09:51:03.807Z</updated>
  <id>http://1921430580.github.io/</id>
  
  <author>
    <name>张栋梁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++学习笔记之函数</title>
    <link href="http://1921430580.github.io/undefined/2e91ca60/"/>
    <id>http://1921430580.github.io/undefined/2e91ca60/</id>
    <published>2022-05-08T02:18:18.000Z</published>
    <updated>2022-05-09T09:51:03.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题</strong></p><ol><li>函数执行的第一步是什么。</li><li>知识点：在函数调用时会发生控制权的转移：主调函数被终端，被调函数开始执行。</li><li>知识点：函数的返回类型不可以是数组或函数，但是可以是数组指针或函数指针。</li><li>局部静态变量的生命周期</li><li>函数的三要素</li><li>函数使用引用形参时的注意事项</li><li>处理可变形参（即可以传递不同数量实参的形参）的方法。</li><li><strong>理解 initializer_list</strong></li><li>函数返回引用和非引用的区别。</li><li>知识点：可以<strong>在 return 语句中直接构造返回的对象</strong>，比如<strong>在 return 语句中调用某个类的构造函数临时构造对象</strong>以返回，<strong>或直接使用列表初始化</strong>。</li></ol><p><strong>回答</strong></p><ol><li>隐式地定义并初始化它的实参。</li><li>知识点：在函数调用时会发生控制权的转移：主调函数被终端，被调函数开始执行。</li><li>函数的返回类型不可以时数组或函数，但是可以是数组指针或函数指针。</li><li>从程序执行到静态变量定义开始，到程序执行结束。</li><li>返回类型、函数名、形参类型</li><li>尽量使用常量引用形参，const 对象、字面值、需要类型转换的对象都只能传递给常量引用形参，不能传递给普通引用形参。</li><li>可以使用 initailizer_list 类型或省略符形参（基本不用）。</li><li><strong>initializer_list 是一个模板，只能使用花括号初始化，本质上 vector 等容器的列表初始化就是采用了 initializer_list 类型作为构造函数的形参。</strong></li><li>返回引用的函数返回的是左值，返回非引用的函数返回的是右值。可以为返回类型是非常量引用的函数的结果赋值。注意返回引用时不能返回局部变量的引用。</li><li>知识点：可以在 return 语句中直接构造返回的对象，比如在 return 语句中调用某个类的构造函数临时构造对象以返回，或直接使用列表初始化。</li></ol><p><strong>问题</strong></p><ol><li>main 的返回值是什么</li><li>assert 预处理宏的用法</li><li>预处理器定义了 5 个对程序调试很有用的名字。</li><li>如何定义函数指针？如何定义类型别名来使用函数指针</li><li>如何使用默认实参</li></ol><p><strong>回答</strong></p><ol><li>如果程序执行成功，main 返回 0，返回其他值表示执行失败。</li><li>用于调试 assert(expr)。</li><li><strong>func</strong>, <strong>FILE</strong>, <strong>LINE</strong>, <strong>TIME</strong>, <strong>DATA</strong></li><li>int (<em>pf) (const int &amp;n); 定义类型别名：using PF &#x3D; int(</em>)(const int &amp;n); PF 和 pf 类型相同。</li><li>通常在函数声明时指定默认实参。有默认值的形参应该在没有默认值的形参之后。可以用全局变量和字面值作为默认实参，不能用局部变量。（区分函数的默认实参和类的类内初始值）</li></ol><h1 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a><strong>第6章 函数</strong></h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a><strong>6.1 函数基础</strong></h2><p>通过<strong>调用运算符 ()</strong> 来执行函数。</p><p><strong>函数的调用会完成****两项工作</strong></p><ol><li><strong>用实参初始化函数对应的形参。</strong></li><li>将控制器转移给被调用函数。</li></ol><p>调用函数后，主调函数被中断，被调函数开始执行。</p><p><strong>函数执行的第一步</strong>：隐式地定义并初始化它的形参。实参是形参的初始值，第一个实参初始化第一个形参。</p><p><strong>return 语句完成****两项工作：</strong></p><ol><li>返回 return 语句中的值（如果有的话）</li><li>将控制权从被调函数转移回主调函数。</li></ol><p><strong>形参</strong></p><p>可以没有形参名，但是函数无法使用未命名的形参，即使形参未命名，也要传入实参。</p><p><strong>返回类型</strong></p><p>返回类型不能是数组或函数类型，但是可以是<strong>数组指针</strong>或<strong>函数指针</strong>。</p><h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a><strong>6.1.1 局部对象</strong></h3><p>名字有作用域，对象有生命周期</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ul><p>形参和函数体内定义的变量统称局部变量。</p><p>函数开始时为形参申请存储空间，函数终止形参被销毁</p><p>在所有函数外定义的对象存在于程序的整个执行过程中</p><p><strong>局部静态变量</strong></p><p>如果要让局部变量的声明周期不局限于函数内，可以将局部变量定义成 <strong>static</strong> 类型。</p><p>局部静态变量的<strong>生命周期</strong>：在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止被销毁。</p><p>如果局部静态变量没有显式的初始值，将执行值初始化。</p><p><strong>注意：局部静态变量是 static 型而不是 const 型</strong></p><h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a><strong>6.1.2 函数声明</strong></h3><p>函数的名字必须在使用前声明。</p><p>函数可以只声明无定义。</p><p>函数的声明和定义的区别在于声明不需要函数体，用一个分号代替。</p><p>函数的声明无需形参的名字（因为声明不包含函数体）。</p><p><strong>函数的三要素</strong>：返回类型、函数名、形参类型。三要素描述了函数的接口。</p><p>建议在头文件中声明函数，在源文件中定义函数。</p><h3 id="6-1-3-分离式编译"><a href="#6-1-3-分离式编译" class="headerlink" title="6.1.3 分离式编译"></a><strong>6.1.3 分离式编译</strong></h3><p>分离式编译允许把程序分割到几个文件中，每个文件独立编译。</p><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a><strong>6.2 参数传递</strong></h2><p>形参初始化的机理和变量初始化一样。</p><h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a><strong>6.2.1 传值参数</strong></h3><p>c++ 中建议使用引用形参代替指针形参</p><h3 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a><strong>6.2.2 传引用参数</strong></h3><p>引用形参在传递实参时直接传入对象。</p><p>如果函数不需要改变引用形参的值，最好声明为常量引用。</p><h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a><strong>6.2.3 const形参和实参</strong></h3><p>用实参初始化形参时会忽略掉顶层 const，即形参类型为 const int 和 const 是一样的。理解：引用是没有顶层 const 的，因此顶层 const 适用于指针及其他类型，对于传值来说传递的是实参的副本，无论如何都不会改变实参，因此形参加不加顶层 const 都是一样的。</p><p><strong>尽量使用常量引用做形参</strong></p><p>注意常量引用的 const 是底层 const。</p><p><strong>可以用字面值初始化常量引用</strong></p><p>不能把 <strong>const 对象、字面值或需要类型转换的对象</strong>传递给普通的引用形参。但是可以传递给常量引用形参。</p><p>注意如果函数 a 把形参定义为了常量引用，函数 b 形参是普通引用，那么不能在 a 中使用 b 调用该常量引用形参。</p><h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a><strong>6.2.4</strong> <strong>数组形参</strong></h3><p>数组的两个特殊性质：不允许拷贝数组、使用数组时常会将其转换成指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;<span class="comment">//三种声明等价，数字 10 没有什么实际影响</span></span><br></pre></td></tr></table></figure><p>编译器只检查传入的实参是否为 <strong>const int*</strong> 类型。</p><p><strong>使用数组做形参确保数组访问不越界的方法：</strong></p><ol><li>使用一个结束标记指定数组已结束，典型代表为 C 风格字符串</li><li>传递指向数组首元素和尾后元素的指针</li><li>专门定义一个表示数组大小的形参。</li></ol><p><strong>数组引用形参</strong></p><p>可以定义数组引用形参。<strong>注意数组的大小是构成数组类型的一部分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="type">int</span> &amp;arr[<span class="number">10</span>]);<span class="comment">//错误：arr 是引用的数组</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>]);<span class="comment">//正确：array 是包含 10 个整数的整型数组的引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *arr[<span class="number">10</span>];<span class="comment">//指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*arr)[<span class="number">10</span>];<span class="comment">//指向数组的指针</span></span><br></pre></td></tr></table></figure><h3 id="6-2-5-main-处理命令行选项"><a href="#6-2-5-main-处理命令行选项" class="headerlink" title="6.2.5 main:处理命令行选项"></a><strong>6.2.5 main:处理命令行选项</strong></h3><p>可以给 main 函数传递实参，不过情况很少。</p><h3 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a><strong>6.2.6 含有可变形参的函数</strong></h3><p><strong>处理不同数量实参的主要方法有两种：</strong></p><ol><li>如果所有实参类型相同，传递一个 <strong>initializer_list</strong> 类型</li><li>使用<strong>省略符形参</strong>，它可以传递可变数量的实参，注意它一般仅用于与 C 函数交互的接口程序</li></ol><p><strong>initializer_list 形参</strong></p><p>initializer_list 也是一种模板类型，<strong>定义在同名的头文件中。</strong></p><p>initializer_list 与 vector 容器大致相同，但是它的元素都是常量值。</p><p><strong>initializer_list 对象只能使用花括号初始化。</strong></p><p>C++ 里的 vector 等各类容器使用列表初始化时本质上都是通过一个采用了 initializer_list 形参的构造函数进行初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;<span class="type">int</span>&gt; initlst;<span class="comment">//默认初始化:空列表</span></span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; initlst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//initlast 的元素数量与初始值一样多</span></span><br><span class="line"><span class="built_in">lst2</span>(initlst); lst2 = initlst;<span class="comment">//拷贝或赋值一个 initializer_list 对象不会复制元素，而是拷贝后两者共享元素。</span></span><br><span class="line">initlst.<span class="built_in">size</span>(); </span><br><span class="line">initlst.<span class="built_in">begin</span>(); initlst.<span class="built_in">end</span>();<span class="comment">//注意返回的是指针</span></span><br></pre></td></tr></table></figure><p>如果向 initailizer_list 形参中传递一个值的序列，必须把序列放在花括号里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; il)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>省略符形参</strong></p><p>省略符形参仅用于 C 和 C++ 通用的类型，大多数类类型的对象传递给省略符形参都无法正确拷贝。</p><p>省略符形参只能出现于形参列表的最后一个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(parm_list,...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a><strong>6.3 返回类型和return语句</strong></h2><p>return的两个作用：</p><ol><li>返回 return 语句中的值</li><li>终止当前正在执行的函数，将控制权返回到调用该函数的地方</li></ol><h3 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a><strong>6.3.1 无返回值函数</strong></h3><p>没有返回值的 return 只能用于无返回值函数</p><p>返回 void 的函数可以没有 return 语句，因为它会在最后一句后面隐式地执行 return。</p><h3 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a><strong>6.3.2 有返回值函数</strong></h3><p>在含有 return 语句的循环和条件后面也应该有一条 return 语句。</p><p>返回一个值和初始化一个变量或形参的方式一样，返回的值用于初始化调用点的变量。</p><p><strong>不要返回局部对象的引用和指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;LiMing&quot;</span></span><br><span class="line">&#125;<span class="comment">//错误，字符串字面值转换成一个局部临时变量，不能返回局部对象的引用</span></span><br></pre></td></tr></table></figure><p> <strong>引用返回左值</strong></p><p>返回引用的函数返回的是左值，其他返回类型得到右值。</p><p>可以为返回类型是非常量引用的函数的结果赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get_val</span>(s,<span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>列表初始化返回值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">if</span>(condition1)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;<span class="comment">// 返回一个空 vector 对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(condition2)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;funcitonX&quot;</span>,s&#125;;<span class="comment">//返回一个列表初始化的 vector 对象    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main 的返回值</strong></p><p>允许 main 函数没有 return 语句直接结束，编译器隐式地插入一条 return 0；</p><p>main 函数地返回值相当于一种状态指示器，返回 0 表示执行成功，返回其他值表示执行失败。</p><p><strong>cstdlib</strong> 头文件定义了两个预处理变量来表示成功与失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EXIT_FAILURE;<span class="comment">//失败</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//成功</span></span><br></pre></td></tr></table></figure><h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a><strong>6.3.3 返回数组指针</strong></h3><p>函数可以返回数组的指针或引用</p><p><strong>声明一个返回数组指针的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pf[<span class="number">10</span>]; <span class="comment">// 错误，指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*pf)[<span class="number">10</span>]; <span class="comment">// 正确，数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>())[<span class="number">10</span>];<span class="comment">// 定义返回数组指针的函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;<span class="comment">// 同上，此处使用了尾置返回类型</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>]; <span class="function">arrT* <span class="title">func</span><span class="params">()</span></span>;<span class="comment">// 使用而类型别名</span></span><br><span class="line"><span class="keyword">decltype</span>(arr)* <span class="built_in">func</span>();<span class="comment">// 使用 decltype</span></span><br></pre></td></tr></table></figure><p>有<strong>三种方法</strong>简化返回数组指针的函数的声明。</p><p><strong>使用类型别名</strong></p><p>可以使用类型别名简化数组指针的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>]; <span class="comment">// arrT 表示含有 10 个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// 函数 func 返回一个指向含有 10 个整数的数组的指针</span></span><br></pre></td></tr></table></figure><p><strong>使用尾置返回类型</strong></p><p>任何函数的定义都可以使用尾置返回，但是它更适用于返回类型复杂的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span> -&gt; <span class="type">int</span></span>;<span class="comment">//返回 int 类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;<span class="comment">//返回一个指向 int 数组的指针</span></span><br></pre></td></tr></table></figure><p><strong>使用 decltype</strong></p><p>如果已知函数返回的指针将指向哪个数组，可以使用 decltype</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd)* <span class="built_in">func</span>();<span class="comment">//返回一个数组指针</span></span><br></pre></td></tr></table></figure><p>注意 decltype 的结果是一个数组，要返回数组指针要加星号。</p><h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a><strong>6.4 函数重载</strong></h2><p>main 函数不能重载</p><p>函数重载无法区分顶层 const 形参和非顶层 const 形参，但是<strong>可以区分底层 const 形参</strong>与普通形参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span>;<span class="comment">//顶层const，无法区分，相当于重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p)</span></span>;<span class="comment">//顶层const，无法区分，相当于重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span></span>;<span class="comment">//底层const，可以区分，一个普通指针，一个常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span></span>;<span class="comment">//底层const，可以区分，一个普通引用，一个常量引用</span></span><br></pre></td></tr></table></figure><p><strong>最好只重载确实非常相似的操作</strong></p><p><strong>const_cast 在重载中的应用</strong></p><p>强制类型转换 const_cast 在重载函数中最有用。一个函数可能同时要有接受常量引用的版本也要有接受非常量引用的版本。</p><p>当要重载常量引用与非常量引用的版本时，在非常量引用的版本中可以通过 const_cast 将参数和返回值从常量引用转换为非常量引用，以实现对常量引用版本的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string&amp; s;</span><br><span class="line"><span class="keyword">const_cast</span> &lt;<span class="type">const</span> string&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用</span></span><br><span class="line"><span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br></pre></td></tr></table></figure><h3 id="6-4-1-重载与作用域"><a href="#6-4-1-重载与作用域" class="headerlink" title="6.4.1 重载与作用域"></a><strong>6.4.1 重载与作用域</strong></h3><p>不同的重载版本要定义在同一作用域中（一般都是全局）</p><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a><strong>6.5 特殊用途语言特性</strong></h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a><strong>6.5.1 默认实参</strong></h3><p>设置默认值的形参必须都放在没有默认值的形参后面。</p><p>使用默认实参的时候省略该实参即可。默认实参负责填补函数调用时缺少的尾部实参。</p><p>通常应该<strong>在函数声明中指定默认实参</strong>，并将该声明放在合适的头文件中。</p><p>局部变量不能作为默认实参，<strong>全局变量</strong>和<strong>字面值</strong>都可以。</p><p>如果函数有默认实参，则调用函数时传入的实参数量可能少于它实际使用的实参数量</p><h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a><strong>6.5.2 内联函数和constexpr函数</strong></h3><p><strong>将规模较小的操作定义为函数****的优点：</strong></p><ol><li>阅读和理解函数调用更简单</li><li>使用函数可以确保行为统一</li><li>修改函数更方便</li><li>函数可以被重复利用</li></ol><p><strong>使用函数的缺点：</strong></p><ol><li>调用函数更慢</li></ol><p>原因：需要保护现场及恢复等一系列操作，可能要拷贝实参，程序要转到新位置继续执行。</p><p><strong>使用内联函数可****以避免调用函数的时间开销</strong></p><p>在函数前用 inline 声明一下即表明是内联函数</p><p>内联函数适用于规模小、流程直接、频繁调用的函数</p><p><strong>constexpr函数</strong></p><p>constexpr 函数被隐式地指定为内联函数</p><p>cosntexpr 是指能用于常量表达式的函数。但是 constexpr 函数不一定返回常量表达式。</p><p>constexpr 函数的<strong>返回类型及所有的形参类型都必须是字面值类型</strong>，<strong>函数体中必须有且只有一条 return 语句</strong>。</p><p>内联函数和 constexpr 函数可以<strong>多次定义</strong>，但是多个定义必须完全一致。</p><p>应该<strong>把内联函数和constexpr函数的定义放到头文件里</strong>。</p><h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a><strong>6.5.3 调试帮助</strong></h3><p><strong>assert 预处理宏</strong></p><p>用法：<strong>assert(expr); assert 宏</strong>定义在头文件 cassert 中。</p><p>如果表达式 expr 为假，assert 输出信息并终止程序，如果表达式为真，assert 什么也不做。</p><p>assert 常用于检查“不能发生”的条件</p><p><strong>NDEBUG 预处理变量</strong></p><p>如果定义了 NDEBUG，则 assert 什么也不做，默认状态下没有定义 NDEBUG。</p><p>预处理器定义了 5 个对于程序调试很有用的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__func__;<span class="comment">//当前函数名的字符串字面值</span></span><br><span class="line">__FILE__;<span class="comment">//当前文件名的字符串字面值</span></span><br><span class="line">__LINE__;<span class="comment">//当前行号的整型字面值</span></span><br><span class="line">__TIME__;<span class="comment">//文件编译时间的字符串字面值</span></span><br><span class="line">__DATA__;<span class="comment">//文件编译日期的字符串字面值</span></span><br></pre></td></tr></table></figure><h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a><strong>6.6 函数匹配</strong></h2><p><strong>当有多个重载函数时，选出要调用的重载函数的流程：</strong></p><p>1、找出所有的候选函数：同名函数并且在调用点声明可见。</p><p>2、从候选函数中找出所有的可选函数：实参数量与形参数量相同且类型相同或能转换为形参的类型。</p><p>3、从可行函数中找出最佳匹配。如果不存在最佳匹配会报错：二义性。</p><p><strong>调用重载函数应尽量避免强制类型转换。</strong></p><h3 id="6-6-1-实参类型转换"><a href="#6-6-1-实参类型转换" class="headerlink" title="6.6.1 实参类型转换"></a><strong>6.6.1 实参类型转换</strong></h3><p>实参类型到形参类型的转换分为几个等级，排序如下：</p><p>1、从数组类型或函数类型转化为对应的指针类型，添加顶层const或删除顶层const</p><p>2、通过const转换实现的匹配。</p><p>3、通过类型提升实现的匹配</p><p>4、通过算术类型转换或指针转换实现的匹配</p><p>5、通过类类型转换实现的匹配</p><p>注意：所有算数类型转换的级别都一样。</p><h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a><strong>6.7 函数指针</strong></h2><p>函数指针是指向函数类型的指针，就像 int 指针是指向 int 类型的指针。</p><p>一种函数指针只能指向一种特定的函数类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;  <span class="comment">// 此函数的类型是 bool(const string&amp;, const string&amp;);</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;);    <span class="comment">// 声明了一个指向 bool(const string&amp;, const string&amp;) 类型函数的指针，注意括号不能少；</span></span><br><span class="line">pf = Compare;                                <span class="comment">// 给指针赋值，指向 Compare 函数</span></span><br><span class="line">pf = &amp;Compare;                               <span class="comment">// 这两种赋值语句完全等价</span></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);             <span class="comment">// 可以直接使用指针替代函数名调用函数。</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);          <span class="comment">// 与上面的等价</span></span><br></pre></td></tr></table></figure><p>当把函数名作为一个值使用时，函数自动地转换成指针。</p><p>不同函数类型的指针间不能相互转换。函数指针也可以指向 nullptr 或 0。</p><p>对于重载函数，指针类型必须与重载函数中的某一个<strong>精确比配。</strong></p><p><strong>函数指针的别名</strong></p><p>函数指针写起来很复杂，尤其是将函数指针作为函数的返回值时，因此一般为其定义别名。定义别名时要注意区分函数类型、函数指针。</p><p>下面几个等价：定义的别名都是函数类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;    <span class="comment">// 定义了一个别名：func，但是 func 是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(Compare)</span> func2</span>;                    <span class="comment">// 定义了一个别名：func2，func2 也是函数类型</span></span><br><span class="line"><span class="keyword">using</span> func3 = <span class="built_in">bool</span>(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;);   <span class="comment">// 定义了一个别名：func3，func3 也是函数类型</span></span><br></pre></td></tr></table></figure><p>注意 decltype(函数名) 返回的不是指针，是函数类型，<strong>加上 * 才表示函数指针。</strong></p><p>下面几个等价：定义的别名都是函数指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*func)</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;  <span class="comment">// 定义了一个别名：func， func 是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(Compare)</span>* func2</span>;                    <span class="comment">// 定义了一个别名：func2，func2 也是函数指针</span></span><br><span class="line"><span class="keyword">using</span> func3 = <span class="built_in">bool</span>(*)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;); <span class="comment">// 定义了一个别名：func3，func3 也是函数指针</span></span><br></pre></td></tr></table></figure><p><strong>函数指针形参</strong></p><p>函数不能作形参，但是<strong>函数指针可以做形参</strong>，之后在调用时可以<strong>直接传入函数名作实参</strong></p><p>函数名做形参也会自动的转换为指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetBigger</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2, <span class="type">bool</span>(*comp)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;  <span class="comment">// 函数指针做形参</span></span><br><span class="line"><span class="built_in">GetBigger</span>(s1, s2, Compare);   <span class="comment">// 实参直接传入函数名 Compare </span></span><br></pre></td></tr></table></figure><p><strong>返回函数指针</strong></p><p>不能返回一个函数，但是可以返回函数指针（注意这时函数名不会自动转换为函数指针）。</p><p>声明一个返回函数指针的函数有几种方法，其中直接声明最麻烦，使用尾置类型和 decltype 更简单一些，但是最好使用类型别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;直接声明&#x27;</span></span><br><span class="line"><span class="built_in">bool</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">double</span>);       <span class="comment">// f1 是一个函数，函数的形参列表为 int，返回类型为函数指针。这个函数指针的类型为 bool (*)(double)，即形参为 double，返回类型为 bool。</span></span><br><span class="line"><span class="string">&#x27;使用尾置类型&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">bool</span><span class="params">(*)</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="string">&#x27;使用 decltype&#x27;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(func)* <span class="built_in">f1</span>(<span class="type">double</span>);     </span><br><span class="line"><span class="string">&#x27;使用类型别名&#x27;</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">bool</span>(*)(<span class="type">double</span>);</span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习笔记之语句</title>
    <link href="http://1921430580.github.io/undefined/ec114a8d/"/>
    <id>http://1921430580.github.io/undefined/ec114a8d/</id>
    <published>2022-04-29T00:38:02.000Z</published>
    <updated>2022-05-08T02:31:41.200Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题</strong></p><ol><li>使用范围 for 语句注意什么？</li><li>try 语句块的使用方式</li><li>C++ 定义了哪些异常类型</li></ol><p><strong>回答</strong></p><ol><li>如果要写元素的话必须要使用引用方式 auto&amp;，但是<strong>建议不论何时都使用引用，且当不需要写时使用常量引用。</strong></li><li>throw 放在 try 块内，catch 用来捕获异常，可以使用省略号来捕获所有的异常类型。如果抛出了异常而未使用 catch 捕获，系统会调用 terminate 终止程序的运行。</li><li>如 exceptIon, bad_alloc, bad_cast，runtime_error, logic_error 等。定义在头文件 exception, new, type_info, stdexcept 等头文件中。</li></ol><p><strong>第5章 语句</strong></p><p><strong>5.1 简单语句</strong></p><p><strong>表达式语句</strong></p><p>一个表达式加上分号就是<strong>表达式语句</strong>。表达式的语句执行表达式并丢弃掉求值结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">3</span>;<span class="comment">//一条没有实际用处的表达式语句</span></span><br><span class="line">cout &lt;&lt; ival;<span class="comment">//一条有用的表达式语句</span></span><br></pre></td></tr></table></figure><p><strong>空语句</strong></p><p>空语句是最简单的语句，只有一个分号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p>用处：用在语法上需要一条语句但逻辑上不需要的地方。比如当循环的全部工作在条件部分就可以完成时。</p><p>使用空语句应该加上注释。</p><p><strong>复合语句（块）</strong></p><p>花括号括起来的语句和声明序列都是<strong>复合语句（块）</strong>。一个块就是一个作用域</p><p>空块的作用等价于空语句。</p><p><strong>5.2 语句作用域</strong></p><p>可以在 if、switch、while、for 语句的控制结构内定义变量。</p><p>常见的语句有条件语句、循环语句、跳转语句三种。</p><p><strong>5.3 条件语句</strong></p><p>两种：if 语句和 switch 语句</p><p><strong>5.3.1 if语句</strong></p><p>if 语句有两种形式，一种有 else 分支，另一种没有。</p><p>c++ 规定 else 与离他最近的尚未匹配的 if 匹配。注意不要搞错。</p><p>使用 if 语句最好在所有的 if 和 else 之后都用花括号。</p><p><strong>5.3.2 switch语句</strong></p><p>switch 语句计算一个<strong>整型表达式</strong>的值，然后根据这个值从几条执行路径中选择一条。</p><p>case 关键字和它对应的值一起被称为 case 标签，case 标签必须为<strong>整型常量表达式</strong>。</p><p><strong>default</strong> 也是一种特殊的 case 标签。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: ++aCnt; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: ++bCnt; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果 switch 条件值于某个 case 标签匹配成功后，程序将从该 case 标签一直执行到 switch 末尾或遇到 break。</p><p>一条 case 后可以跟多条语句，不必用花括号括起来。</p><p>一般在每个 case标签后都有一条 break 语句。如果需要两个或多个值共享同一组操作，可以故意省略掉 break 语句。</p><p>c++ 程序的形式比较自由，case 标签之后不一定要换行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        ++Cnt;</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般不要省略 case 分支最后的 break 语句。如果没有 break 语句，最好注释一下。</p><p>如果没有任何一个 case 标签匹配 switch 表达式的值，就执行 default 分支。</p><p>即使不准备在 default 下做任何工作，最好也定义一个 default 标签。</p><p>如果要在 case 分支定义并初始化变量，应该定义在块内以约束其作用域。</p><p><strong>5.4 迭代语句</strong></p><p>三种：while 语句、for 语句（包括范围 for 语句）、do while 语句</p><p><strong>5.4.1 while语句</strong></p><p>while 的条件不能为空。条件部分可以是一个表达式或<strong>带初始化的变量声明</strong>。</p><p>定义在 while 条件部分或循环体内的变量每次迭代都会重新创建和销毁。</p><p>while 适合不知道循环多少次的情况。</p><p><strong>5.4.2 传统的for语句</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement; condition; expression)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>init-statement 可以是声明语句、表达式语句或空语句。init-statement 可以定义多个对象，但是只能有一条声明语句。</p><p>expression 在每次循环之后执行。</p><p>for 语句头能省略掉三者中的任意一个或全部。</p><p>省略 condition 等于条件恒为 true。</p><p><strong>5.4.3 范围for语句</strong></p><p>范围 for 语句用来遍历容器或其他序列的所有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>expression 表示的必须是一个序列，可以是花括号括起来的初始值列表。这些序列的共同的是都可以返回迭代器的 begin 和 end 成员。</p><p>declaration 定义一个能从序列中元素转换过来的<strong>变量（不是迭代器）</strong>。最简单的方法是使用 auto 类型说明符。</p><p>如果需要对容器中的元素执行写操作，必须<strong>将循环变量声明成引用类型</strong>。</p><p><strong>循环变量可以声明为对常量的引用，不需要写时最好都声明为常量引用</strong></p><p>每次迭代都会<strong>重新定义</strong>循环控制变量，并将其初始化为序列的下一个值。</p><p>范围 for 语句不能改变序列的元素数量。因为其预存了 end() 的值，改变元素数量后 end() 的值就可能失效了。</p><p><strong>5.4.4 dowhile语句</strong></p><p>do while 语句与 while 语句的唯一区别就是它先执行循环体后检查条件。即至少执行一次循环。</p><p>注意：do while 后<strong>不要忘了加分号。</strong></p><p>因为 condition 在循环体后面，所以 condition 使用的变量应该定义在循环体外面。</p><p><strong>5.5 跳转语句</strong></p><p>四种：break、continue、goto、return</p><p><strong>5.5.1 break语句</strong></p><p>break 语句终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始执行。</p><p>break 语句只能出现在迭代语句或 switch 内部。</p><p><strong>5.5.2 continue语句</strong></p><p>continue 语句终止最近的循环中的当前迭代并开始下一次迭代。</p><p>continue 适用范围比 break 少了一个 switch</p><p><strong>5.5.3 goto语句</strong></p><p>goto 语句的作用是从 goto 语句无条件跳转到<strong>同一函数内</strong>的另一条语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label: <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure><p>label 是用于标识一条语句的标示符</p><p>标签标示符独立于变量或其他标示符的名字，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</p><p>如果 goto 语句跳回了一条变量的定义之前意味着系统将会销毁该变量，然后重新创建它。</p><p><strong>不要使用 goto</strong>，它会令程序又难理解又难修改。</p><p><strong>5.6 try语句块和异常处理</strong></p><p>异常是指存在于运行时的反常行为，典型的异常有失去数据库连接和遇到意外输入等。处理异常可能是设计系统时最难的一部分。</p><p>当程序检测到一个无法处理的问题时，就需要<strong>异常处理</strong>，此时检测到问题的部分应该发出检测信号。</p><p>如果程序里有可能引发异常的代码，也应该有专门的代码处理问题。</p><p>C++ 的异常处理机制为<strong>异常检测</strong>和<strong>异常处理</strong>提供支持，它包括：</p><ol><li><strong>throw 表达式：</strong>异常检测部分使用 throw 表达式来表示遇到了无法处理的问题。称为 throw 引发了异常。</li><li><strong>try 语句块：</strong>异常处理部分使用 try 语句块处理异常。try 语句块以关键字 try 开始，以一个或多个 catch 子句结束。</li><li><strong>一套异常类：</strong>用于在 throw 表达式和相关的 catch 子句间传递异常的具体信息。</li></ol><p><strong>5.6.1 throw 表达式</strong></p><p>throw 表达式包含关键字 throw 和紧随其后的一个表达式，表达式的类型就是抛出的异常类型。</p><p>即 throw 后面跟一个异常类型的对象（必须同时使用 string 或 C 风格字符串对其初始化）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must be same as size&quot;</span>);<span class="comment">//使用 throw 表达式抛出一个运行时错误。</span></span><br></pre></td></tr></table></figure><p><strong>5.6.2 try语句块</strong></p><p>跟在 try 块后面的是一个或多个 catch 子句。catch 子句包括三部分：关键字 catch、括号内一个异常类型的对象的声明（叫做异常声明）、一个块。</p><p>当 try 语句块中抛出了一个异常，如果该异常类型与 catch 子句括号中的异常类型相同，就会执行该 catch 子句。</p><p>catch 一旦完成，程序就跳转到 try 语句块最后一个 catch 子句之后的那条语句继续执行。</p><p>在 catch 后面的括号里使用省略号(…)可以让 catch 捕获所有类型的异常。</p><p>每个标准库异常类都有一个 <strong>what 成员函数</strong>，它没有参数，返回初始化该对象时所用的 C 风格字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must be same as size&quot;</span>);<span class="comment">//try 语句块抛出了一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(runtime_error err)<span class="comment">//在 catch 后面的括号中声明了一个“runtime_error”类型的对象，与 try 抛出的异常类型相同，接下来执行此子句。</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; err.<span class="built_in">what</span>();<span class="comment">//输出 &quot;Data must be same as size&quot;</span></span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p><strong>函数在寻找处理代码的过程中退出</strong></p><p>throw 语句可能出现在嵌套的 try 语句块中或在 try 语句块中调用的某个函数内。当异常被抛出，程序会<strong>从内到外一层层寻找相应类型的 catch 子句。</strong>如果最后还是没找到，系统会<strong>调用 terminate 函数并终止当前程序的执行。</strong></p><p>如果 throw 语句外就没有 try 语句块，也会执行 terminate 函数。</p><p>理解：异常中断了程序的正常流程。当发生异常，程序执行到一半就中断了，可能会存在如资源没有正常释放，对象没有处理完成等情况。异常安全的代码要求在异常发生时能正确执行清理工作。这个非常困难。</p><p><strong>5.6.3 标准异常</strong></p><p>C++ 标准库定义了一组异常类，用于报告标准库函数遇到的问题。他们定义在 4 个头文件中。</p><p>定义在 <strong>stdexcept</strong> 头文件中的类型必须使用 string 对象或 C 风格字符串来初始化他们。其他 3 个头文件中的 3 中类型则只能默认初始化，不能提供初始值。</p><p>异常类型只有一个 what 成员函数，该函数没有参数，返回是一个 C 风格字符串的指针，目的是提供关于异常的文本信息。</p><p>对于无初始值的异常类型，what 返回的内容由编译器决定，有初始值的返回初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;exception头文件&#x27;</span></span><br><span class="line">exception           <span class="comment">// 异常类 exception 是最通用的异常类。它只报告异常的发生，不提供额外信息。</span></span><br><span class="line"><span class="string">&#x27;new头文件&#x27;</span></span><br><span class="line">bad_alloc           <span class="comment">// 异常类 bad_alloc。在使用 new 分配动态内存失败时抛出</span></span><br><span class="line"><span class="string">&#x27;type_info头文件&#x27;</span></span><br><span class="line">bad_cast            <span class="comment">// 异常类型 bad_cast。经常发生在使用 dynamic_cast 时发生。</span></span><br><span class="line"><span class="string">&#x27;stdexcept头文件&#x27;</span></span><br><span class="line">exception</span><br><span class="line">runtime_error       <span class="comment">// 只有在运行时才能检测出的问题</span></span><br><span class="line">range_error         <span class="comment">// 运行时错误：生成的结果超出了有意义的值域范围</span></span><br><span class="line">overflow_error      <span class="comment">// 运行时错误：计算上溢</span></span><br><span class="line">underflow_error     <span class="comment">// 运行时错误：计算下溢</span></span><br><span class="line">logic_error         <span class="comment">// 程序逻辑错误</span></span><br><span class="line">domain_error        <span class="comment">// 逻辑错误：参数对象的结果值不存在</span></span><br><span class="line">invalid_argument    <span class="comment">// 逻辑错误：无效参数</span></span><br><span class="line">length_error        <span class="comment">// 逻辑错误：试图创建一个超出该类型最大长度的对象</span></span><br><span class="line">out_of_range        <span class="comment">// 逻辑错误：使用一个超出有效范围的值</span></span><br></pre></td></tr></table></figure><p>上面的异常类之间存在继承关系，其中 exception 是所有其他类的基类，总的继承关系如下图</p><p>​    <img src="https://note.youdao.com/yws/public/resource/80ef131f62e5733164aa3fd1f11c9b29/xmlnote/8A824B95651E4A219BAB42B0D3803B49/33842" alt="0"></p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> string&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习笔记之表达式</title>
    <link href="http://1921430580.github.io/undefined/ca1d4fd/"/>
    <id>http://1921430580.github.io/undefined/ca1d4fd/</id>
    <published>2022-04-26T08:23:36.000Z</published>
    <updated>2022-05-09T09:49:54.444Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题</strong></p><ol><li>左值与右值的不同</li><li>左值与右值对 decltype 的影响</li><li>整数除法的结果是如何舍入的</li><li>理解运算符的返回值</li><li>区分递增运算符的前置与后置版本。</li><li>位运算符的使用要注意什么</li><li>运算符的结合顺序是怎样的</li><li>sizeof 运算符的返回值是什么</li><li>常见的隐式类型转换的方式</li><li>四种显示类型转换是什么</li><li>常见的如 int 转换为 double 这样的转换用什么</li><li>const_cast 用于什么时候</li><li>旧式的两种强制类型转换方式</li><li>需要记住的典型运算符的优先级</li></ol><p><strong>回答</strong></p><ol><li>使用左值使用的是<strong>对象的身份（在内存中的位置）</strong>，使用右值使用的是<strong>对象的值（内容）</strong>。需要右值的地方可以用左值代替，反之不行。</li><li><strong>如果 decltype 中的表达式返回的是左值，那么 decltype 得到是一个引用类型。</strong></li><li>向零舍入</li><li>采用运算符进行各类运算时，把运算符理解为函数，返回值是运算符函数的返回值，cin&gt;&gt;10 的返回值是运算符 &gt;&gt; 的返回值</li><li>前置版本直接返回改变后的运算对象，后置版本返回的是运算对象改变前的原始值的副本。对迭代器使用后置递增消耗很大。</li><li>建议使用位运算符处理无符号类型。C++中使用位运算符处理带符号数的运算结果依赖于机器。</li><li>如果优先级相同，除了赋值运算符，其他运算符都是从左向右结合。</li><li>sizeof 也是运算符，它返回一条表达式或一个类型所占的<strong>字节数</strong>。</li><li>算数运算中小整型（bool,char,short）提升为大整型（int）、整型转换为浮点型，条件里非布尔值转换为布尔值，初始化时初始值转换为变量的类型，赋值时右侧转换为左侧类型，算术运算或关系运算的运算对象被转换为同一种类型。数组和函数转换为指针，指向非常量的指针转换为指向常量的指针，c风格字符串转换为string，cin&gt;&gt;s 返回的的 cin 转换为 bool 值。</li><li><strong>static_cast(expression), const_cast</strong>, dynamic_cast, reinterpret_cast(不要用它)。</li><li>使用 static_cast(num) 来转换。</li><li>const_cast 用于移除或增加对象的底层 const，即用于使不能修改引用对象值的引用和不能修改指向对象值的指针变成可以修改的，或者反过来。</li><li>int(a) 和 (int)a。两种都可以，但是建议使用新式的代替。</li><li>作用域运算符优先级是最高的，成员访问运算符(. 和 -&gt;)的优先级高于括号，也是非常高的。递增和递减的优先级也很高，是括号之下最高的。</li></ol><h1 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a><strong>第4章 表达式</strong></h1><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a><strong>4.1 基础</strong></h2><h3 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a><strong>4.1.1 基本概念</strong></h3><p>​表达式由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果。<br>​字面值和变量是最简单的表达式。<br>​把运算符和运算对象结合起来可以生产较复杂的表达式。</p><p>​一元运算符：作用域一个运算对象的运算符，如取地址符（&amp;）和解引用符（*）<br>​二元运算符：要求两个运算对象的类型相同或可以转换为同一种类型。</p><p>​小整型（bool, char, short）通常会被提升为大整型，主要是 int。</p><p>​运算符重载：当运算符作用于类类型的对象时，用户可以自行定义含义，即重载运算符。</p><p>例：IO库的&gt;&gt;和&lt;&lt;，string对象、vector对象和迭代器使用的运算符</p><p><strong>左值和右值</strong></p><p>C++表达式要么是左值，要么是右值<br>        C语言：左值可以位于赋值语句的左侧、右值不能。<br>        C++语言中，要复杂得多<br>                右值：取不到地址的表达式<br>                左值：能取到地址的表达式<br>                        常量对象为代表的左值不能作为赋值语句的左侧运算对象<br>                        某些表达式的求值结果是对象，但他们是右值</p><p>当一个对象被作用右值的时候，用的是对象的值（内存中的内容）<br>当一个对象被当做左值的时候，用的是对象的身份（内存中的位置）</p><p>通常情况：左值可以当成右值，实际使用的是它的内容（值）。不能把右值当成左值（也就是位置）</p><p>​取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。<br>​内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果表达式的求值结果是左值，<span class="keyword">decltype</span>作用于该表达式（不是变量）得到一个引用类型。例如，对于<span class="type">int</span> *p ：</span><br><span class="line">因为解引用运算符生成左值，所有<span class="keyword">decltype</span>(*p)的结果是<span class="type">int</span>&amp;</span><br><span class="line">因为取地址运算符生成右值，所以<span class="keyword">decltype</span>(&amp;p)的结果是<span class="type">int</span> **</span><br></pre></td></tr></table></figure><p>运算符对于作用对象是左值还是右值会有要求，比如赋值运算符的左侧运算对象必须是左值。</p><h3 id="4-1-2-优先级与结合律"><a href="#4-1-2-优先级与结合律" class="headerlink" title="4.1.2 优先级与结合律"></a><strong>4.1.2 优先级与结合律</strong></h3><p>表达式 的计算结果，依赖运算符的优先级（precedence）、结合律（associativity） 以及运算对象的求值顺序（order of evaluation）</p><p><strong>左结合律</strong>：如果运算符优先级相同，按照从左向右的顺序组合运算对象。大部分二元运算符满足左结合律。</p><h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a><strong>4.1.3 求值顺序</strong></h3><p><strong>4种运算符</strong>明确规定了运算对象的求值顺序：逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)</p><p><strong>处理复合表达式的两个建议：</strong></p><ol><li>不确定优先级与结合律时使用括号</li><li>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象。</li></ol><h2 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a><strong>4.2 算术运算符</strong></h2><p>算术运算符有 3 组，按优先级从高到低依次是</p><ol><li>+、- ：一元正号与一元负号</li><li>*、&#x2F;、% ：乘法、除法、求余</li><li>+、- ：加法、减法</li></ol><p>注意一元正负号的优先级最高，求余也是一种算术运算。</p><p>一元负号运算符对运算对象值取负后，返回其（提升后的）副本</p><p>整数除法的结果是向零舍入。</p><p>求余运算符的运算对象必须是整数，<strong>运算结果始终与被除数符号相同</strong></p><h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a><strong>4.3 逻辑和关系运算符</strong></h2><ul><li>逻辑运算符：！、&amp;&amp;、||。逻辑运算符的作用对象必须是能转换成布尔值的类型</li><li>关系运算符：&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;, &#x3D;&#x3D; ：大于小于的优先级高于等于和不等于</li></ul><p>逻辑运算符与关系运算符的求值结果都是布尔值。</p><p>逻辑与和逻辑或都是先求左侧对象的值再求右侧。也就是 &amp;&amp; 和 || 两个运算符自带了个 if 的功能。</p><p><strong>布尔字面值</strong></p><p>使用算术值做条件时直接用，不要与布尔值做比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a);<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="literal">true</span>);<span class="comment">//错误：会将 true 先转换为 int 再比较，比较结果是不相等</span></span><br></pre></td></tr></table></figure><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a><strong>4.4 赋值运算符</strong></h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p><p>C++ 11 允许使用花括号括起来的初始值列表作为右侧运算对象。初始化列表可以为空，此时将进行值初始化。</p><p>赋值运算符满足<strong>右结合律</strong>。 赋值运算符优先级较低。</p><p><strong>复合赋值运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+=; -=; *=; /=; %=; &lt;&lt;=; &gt;&gt;=; &amp;=; ^=; |=;</span><br></pre></td></tr></table></figure><p>位运算也可以使用赋值运算符。</p><p>复合赋值运算符只求值一次，而普通运算符需要两次。(a&#x3D;a+1 要先求一次 a+1，再将结果赋值给 a)</p><h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a><strong>4.5 递增和递减运算符</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i; <span class="comment">// j=1,i=1:前置版本，首先将运算对象加 1，然后将改变后的对象作为求值结果，得到递增之后的值，将对象本身作为左值返回</span></span><br><span class="line">j = i++; <span class="comment">// j=1,i=2;后置版本，也是将运算对象加 1，但是求值结果是运算对象改变之前那个值的副本。得到递增之前的值，将对象的原始值的副本返回。</span></span><br></pre></td></tr></table></figure><p>如无必要，不要使用后置版本。</p><p><strong>在一条语句中混用解引用和递增运算符</strong></p><p>*<strong>p++</strong> ：p++将 p 的值加一，然后返回 p 的初始值的副本作为求值结果用于解引用。(递增运算符优先级高于解引用)。推荐使用这种写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//输出元素直到遇到第一个负值</span></span><br><span class="line"><span class="keyword">while</span> (pbeg != v.<span class="built_in">end</span>() &amp;&amp; *beg &gt;= <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; *pbeg++ &lt;&lt; endl; <span class="comment">//输出当前值并将pbg移动到下一个元素</span></span><br></pre></td></tr></table></figure><h2 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a><strong>4.6 成员访问运算符</strong></h2><p>点运算符和箭头运算符都可以用来访问成员。</p><p>ptr-&gt;mem 等价于 (*ptr)-&gt;mem</p><h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a><strong>4.7 条件运算符</strong></h2><p>cond ? expr1 : expr2</p><p>可以使用嵌套条件运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = (grade&gt;<span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> : (grade&lt;<span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>条件运算符优先级非常低</strong>，通常都要加括号</p><h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a><strong>4.8 位运算符</strong></h2><p>位运算符作用于整数类型的对象。</p><p>位运算符有六种：位求反、位与、位或、位异或、左移、右移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~a; a&amp;b; a|b; a^b; a&lt;&lt;<span class="number">2</span>; a&gt;&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>如果运算对象是“小整型”，值会被自动提升为较大的整数类型。</strong></p><p>运算对象可以带符号，也可以不带符号。不带符号的运算结果是固定的，<strong>带符号的运算结果依赖于机器</strong>。</p><p>左移操作处理带符号值是一种未定义的行为。</p><p><strong>在 C++ 中，建议仅用位运算符来处理无符号类型。</strong></p><p><strong>移位运算符</strong></p><p>使用移位运算符，移动的位数必须<strong>严格小于</strong>结果的位数，否则会产生未定义的行为。</p><p>&lt;&lt; 运算符在右侧插入 0，左侧移动超出边界的值舍弃掉。</p><p>&gt;&gt; 运算符处理无符号数时在左侧插入 0，右侧移动超出边界的值舍弃掉。</p><p>&gt;&gt; 运算符处理有符号数时可能在左侧插入 0 也可能插入符号位的副本，由机器决定使用哪种方式。</p><p>标准 IO 库所使用的 &lt;&lt; 和 &gt;&gt; 都是<strong>重载版本</strong>。</p><p>移位运算符满足左结合律，以下两种等价。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">((cout &lt;&lt; a) &lt;&lt;b ) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>位求反、位与、位或、位异或</strong></p><p>这几种运算符处理 char 时，都会把 char 类型的运算对象首先零扩展提升成 int 类型再进行位运算。</p><p><strong>在写代码时，考虑到可移植性，选取数据类型应考虑到某一类型的最大字节和最小字节，比如 int 的最小位是 2 字节。</strong></p><h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a><strong>4.9 sizeof运算符</strong></h2><p>sizeof 是一个运算符。</p><p>sizeof 返回<strong>一条表达式</strong>或<strong>一个类型名字</strong>所占的字节数，值为 size_t 类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(type)</span><br><span class="line"><span class="keyword">sizeof</span> expr;<span class="comment">//返回表达式结果类型的大小</span></span><br></pre></td></tr></table></figure><p>对数组执行 sizeof 运算符得到的是整个数组所占空间的大小。不会把数组转换为指针来处理。</p><p>但是对指针执行 sizeof 运算符得到的是指针类型的大小，也就是 8。</p><p>对 string 或 vector 对象执行 sizeof 运算只返回<strong>该类型固定部分的大小</strong>，不会计算对象中的元素占了多少空间。</p><p>可以用 sizeof 获得数组中元素的个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(*arr);<span class="comment">//返回的是数组 arr 的元素数量</span></span><br></pre></td></tr></table></figure><h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a><strong>4.10 逗号运算符</strong></h2><p>在 for 循环中可以用逗号分隔两个不同的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i!=n; i++,j++)</span><br></pre></td></tr></table></figure><p>注意不要在判断条件那里使用逗号分隔不同的条件，那样只会返回逗号分隔的最后一个表达式的值。</p><h2 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a><strong>4.11 类型转换</strong></h2><p>c++ 不会直接将两个不同类型的值相加，会先通过类型转换把运算对象的类型统一后再求值。</p><p><strong>隐式类型转换****的发生场景</strong></p><ol><li>比 int 类型小的整型值首先提升为较大的整数类型</li><li>在条件里，把非布尔值转换成布尔值</li><li>初始化过程中，初始值转换为变量的类型</li><li>赋值时，右侧运算对象转换成左侧类型</li><li>算数运算或关系运算的运算对象有多种类型，转换成一种。</li></ol><h3 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a><strong>4.11.1 算术转换</strong></h3><p>运算符的运算对象将转换成所有运算对象中最宽的类型。如果表达式中既有整型也有浮点型，一般会<strong>把整型转换为浮点型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159L</span> + <span class="string">&#x27;a&#x27;</span>;<span class="comment">//先将&#x27;a&#x27;提升成 int，然后把 int 转换成 long double</span></span><br></pre></td></tr></table></figure><p><strong>整型提升</strong></p><p>整型提升把小整数类型（包括 char、bool等）转换成较大的整数类型。如果 int 可以就转换成 int，否则提升成 unsigned int 类型</p><p><strong>无符号类型的运算对象</strong></p><p>如果一个是无符号一个带符号。如果无符号类型不小于带符号类型（比如都是 4 字节），则带符号转换为无符号</p><p>如果无符号类型小于带符号，转换结果依赖机器。尽量避免。</p><h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2 其他隐式类型转换"></a><strong>4.11.2 其他隐式类型转换</strong></h3><p><strong>数组转换成指针</strong></p><p>大多数情况下数组自动转换成指向数组首元素的指针。（decltype关键字参数、取地址符(&amp;)、sizeof、typeid 都不会发生这种转换）</p><p><strong>指针的转换</strong></p><p>0 或 nullptr 都能转换成任意指针类型。指向非常量的指针能转换成 **void***。指向所有对象的指针都能转换成 **const void***。</p><p><strong>转换成常量</strong></p><p>指向非常量的指针转换成指向相应常量类型的指针</p><p><strong>类类型定义的转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s);<span class="comment">//将 cin 转换为 bool 值</span></span><br><span class="line">string s = <span class="string">&quot;value&quot;</span>;<span class="comment">//将 c 风格字符串转换为 string</span></span><br></pre></td></tr></table></figure><h3 id="4-11-3-显式转换"><a href="#4-11-3-显式转换" class="headerlink" title="4.11.3 显式转换"></a><strong>4.11.3 显式转换</strong></h3><p><strong>显示转换</strong>即使用<strong>强制类型转换</strong>。</p><p>强制类型转换<strong>非常危险</strong>，尽量避免使用。如果使用了，应反复思考是否可以用其他方式代替。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">castname</span>&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure><p>castname 有四种：<strong>static_cast、dynamic_cast、const_cast、reinterpret_cast</strong> 。它指定了执行哪种转换。</p><p><strong>static_cast</strong></p><p>任何类型转换，只要不包含底层 const，都可以用 static_cast</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j)/i; <span class="comment">//将 j 转换成 double 以便执行浮点数除法</span></span><br></pre></td></tr></table></figure><p>当把较大的类型转换为较小的类型时，static_cast 很有用。这时它告诉读者和编译器：我们知道且不在乎精度损失。平时编译器会给警告，显式转换后就不警告了。</p><p><strong>const_cast</strong></p><p>const_cast 只能改变对象的底层 const。可以去掉或增加 const 性质。</p><p><strong>只有</strong> const_cast 能改变表达式的常量属性，其他都不行。</p><p>cosnt_cast 常用于有函数重载的上下文中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string&amp; s;</span><br><span class="line"><span class="keyword">const_cast</span> &lt;<span class="type">const</span> string&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用</span></span><br><span class="line"><span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong></p><p>它依赖于机器，使用门槛很高，且使用时充满风险，<strong>不要用它</strong>。</p><p><strong>旧式的强制类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(a);<span class="comment">// 函数形式的强制类型转换</span></span><br><span class="line">(<span class="type">int</span>)a;<span class="comment">// c 语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure><p>旧式的强制类型转换本质上采用 const_cast、static_cast 或 reinterpret_cast 的一种。</p><p>旧式与新式相比没那么清晰明了，如果出现问题，追踪困难。</p><h2 id="4-12-运算符优先级表"><a href="#4-12-运算符优先级表" class="headerlink" title="4.12 运算符优先级表"></a><strong>4.12 运算符优先级表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:: <span class="comment">//作用域</span></span><br><span class="line">. 和 -&gt; <span class="comment">//成员访问。注意它非常高，比括号还高。</span></span><br><span class="line">[] 和 ()</span><br><span class="line">++、-- <span class="comment">//注意递增递减运算符的优先级非常高，括号之下最高的。</span></span><br><span class="line"></span><br><span class="line">, <span class="comment">//逗号是最低的</span></span><br></pre></td></tr></table></figure><p>​    <img src="https://note.youdao.com/yws/public/resource/9f031e468a3ae180f86b9aaa422e0dd3/xmlnote/451874ADAE37439E8F9CEAA80060296F/52205" alt="0"></p><p>​    <img src="https://note.youdao.com/yws/public/resource/9f031e468a3ae180f86b9aaa422e0dd3/xmlnote/DFA276B09A874DA9899D5ED6577886E3/52202" alt="0"></p>]]></content>
    
    
    <summary type="html">一个学习笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记之字符串、向量、和数组</title>
    <link href="http://1921430580.github.io/undefined/7f71bab2/"/>
    <id>http://1921430580.github.io/undefined/7f71bab2/</id>
    <published>2022-04-23T03:39:19.000Z</published>
    <updated>2022-05-09T09:48:57.594Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题</strong></p><ol><li>使用加号连接字符串&#x2F;string时要注意什么</li><li>string 的索引是什么类型，s.size() 返回什么类型。</li><li>如何方便地判断 string 中的某个字符的类型（比如是数字还是字母）以及转换某个字符的大小写。</li><li>值初始化的结果是怎样的</li><li>定义 c 风格数组时数组维度的限制条件</li><li>如何使用数组来初始化 vec</li><li>string 类型可以隐式转化为 c 风格字符串（即字符数组）吗？</li><li>如何将 string 类型转化为 c 风格字符串</li><li>使用 getline() 函数从输入流读取字符串存到 string 中，存储的内容有换行符吗？</li><li>使用范围for循环要注意什么？</li></ol><p><strong>回答</strong></p><ol><li>加号两边至少有一个是 string 类型，不能都是字符串</li><li>都是 string::size_type 类型，是无符号值。</li><li>使用 <strong>cctype</strong> 头文件中的 isalnum(),  isalpha(), isdigit(), isupper(), islowwer(), ispunct(), isspace(), tolower(), toupper() 等类型。</li><li>值初始化会将内置类型初始化为 0，类类型由类自己来默认初始化。</li><li><strong>维度必须是个常量表达式，即在编译阶段就可以确定值</strong>。（因为数组维度是数组的类型的一部分，而 <strong>C++ 是静态语言，即在编译阶段就要确定类型</strong>）</li><li>vector vec(begin(arr),end(arr));</li><li>不可以（从 C 风格字符串到 string 的转换是用了 string 的转换构造函数，而 string 并没有定义到 C 风格字符串的类型转换运算符）</li><li>使用 c_str() 函数</li><li>没有换行符。</li><li>如果要修改循环变量的值要将其声明为引用类型：auto &amp;</li></ol><p><strong>问题</strong></p><ol><li>如果容器为空，begin() 的返回值是什么？</li><li>使用数组时要注意数组维度的什么特点？</li><li>区分 int *ptrs[10]; int (*ptrs)[10]; int (&amp;ptrs)[10] 的不同含义</li><li>C风格字符串属于什么类型？</li></ol><p><strong>回答</strong></p><ol><li>返回的是尾后迭代器，和 end() 的返回值一样。</li><li>使用数组时注意数组的维度必须是个常量表达式，因为数组的维度也属于数组类型的一部分，而编译器在编译阶段就需要知道数组类型。</li><li>他们分别定义了：一个包含10个整型指针的数组，一个指向包含10个整型值的数组的指针，一个包含10个整型值的数组的引用。</li><li>C风格字符串本身不是类型，而是一种写法，它的类型是字符数组。<strong>要从字符数组的角度来理解C风格字符串的各项操作。</strong></li></ol><h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a><strong>第3章 字符串、向量和数组</strong></h1><p>string、vector是两种最重要的标准库类型，迭代器是一种与 string 和 vector 配套的标准库类型。</p><p>内置数组和其他内置类型一样，数组的实现和硬件密切相关，因此与string和vector相比，数组在灵活性上稍显不足。</p><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a><strong>3.1 命名空间的using声明</strong></h2><p>可以对单个名字进行独立的using声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> <span class="comment">//::是域操作符</span></span><br><span class="line"><span class="type">int</span> v1, v2;</span><br><span class="line">std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2</span><br><span class="line">     &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>●using namespace::name;</p><p>●using namespace nameSpaceName;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using declarations for names from the standard library</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v1, v2;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2</span><br><span class="line">     &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>头文件里不应包含 using 声明</strong>，因为会被拷贝到引用该头文件的文件中</p><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a><strong>3.2 标准库类型string</strong></h2><p>string 表示可变长的字符序列，需要包含string头文件</p><p>string 定义在命名空间 using 中。  </p><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a><strong>3.2.1 定义和初始化string对象</strong></h3><p>string 默认初始化为一个空的 string。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1;       <span class="comment">//将 s1 默认初始化为一个空的 string</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(s2)</span></span>;   <span class="comment">//使用拷贝构造函数进行的拷贝初始化。s1 是 s2 的拷贝。</span></span><br><span class="line">string s1 = s2;  <span class="comment">//使用拷贝赋值运算符进行的拷贝初始化。s1 是 s2 的拷贝。</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;  <span class="comment">//s1 是字面值 &quot;value&quot; 去除最后一个空字符后的拷贝。</span></span><br><span class="line">string s1 = <span class="string">&quot;value&quot;</span>; <span class="comment">//同上。</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//s1 初始化为 n 个 &#x27;c&#x27;。</span></span><br></pre></td></tr></table></figure><p>注意：使用字符串字面值或字符数组初始化 string 对象时，string 对象中是不包含末尾的空字符的，它会将字符数组中末尾的空字符去掉。</p><p><strong>初始化方式</strong></p><p>拷贝初始化：使用等号</p><p>直接初始化：不使用等号</p><p>列表初始化：使用花括号{}</p><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a><strong>3.2.2 string对象上的操作</strong></h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>os&lt;&lt;s</td><td>将s写到输出流os当中，返回os</td></tr><tr><td>is&gt;&gt;s</td><td>从is中读取字符串赋给s，字符串以空白分隔，返回is</td></tr><tr><td>getline( is,s )</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty()</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size()</td><td>返回s中字符的个数，返回值为string::size_type类型</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用，位置n从0记起</td></tr><tr><td>s1+s2</td><td>返回s1和s2连接后的结果</td></tr><tr><td>s1&#x3D;s2</td><td>用s2的副本替代s1中原来的字符</td></tr><tr><td>s1&#x3D;&#x3D;s2</td><td>判断s1和s2是否完全一样</td></tr><tr><td>s1!&#x3D;s2</td><td>判断s1和s2是否不完全一样</td></tr><tr><td>&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;</td><td>利用字符在字典中的顺序进行比较</td></tr></tbody></table><p>因为 cin 会<strong>自动忽略开头的空白并遇到空白就停止读取</strong>，因此不能使用 cin 读取句子；</p><p>字符串字面值与 string 是两种不同的类型</p><p><strong>读写string对象</strong></p><p>可以使用 cin, cout 来读写 string 对象，也可以使用 stringstream 来读写 string 对象。</p><p><strong>getline 函数</strong></p><p>getline() 定义在<strong>头文件 string</strong> 中，以一个 istream 对象和一个 string 对象为输入参数。getline() 读取输入流的内容直到遇到换行符停止，然后将读入的数据存入 string 对象。</p><p>注意 getline 会将换行符也读入，但是不将换行符存入 string 对象。<strong>即触发 getline() 函数返回的那个换行符实际上被丢弃掉了。</strong></p><p>getline() 只要一遇到换行符就结束读取操作并返回结果，即使一开始就是换行符也一样，这种情况下会得到一个空 string。</p><p><strong>getline() 与 &lt;&lt; 一样，会返回它的流参数。</strong>所以可以用 getline 的结果作为条件。</p><p><strong>string::size_type 类型</strong></p><p>string 的 size() 成员函数返回一个 string::size_type 类型的值。</p><p>大多数标准库类型都定义了几种配套的类型，这些<strong>配套类型体现了标准库与机器无关的特性</strong>。</p><p>在具体使用时，通过作用域操作符来表明 size_type 是在类 string 中定义的。</p><p>string::size_type 是<strong>无符号值</strong>，可以确定的是它足够存放任何 string 对象的大小。</p><p>C++11 允许通过 auto 和 decltype 来获得此类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = s.<span class="built_in">size</span>();<span class="comment">// len 的类型是 string::size_type</span></span><br></pre></td></tr></table></figure><p>不要在同一个表达式中混用 size_type 和 int 类型。</p><h3 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3 处理string对象中的字符"></a><strong>3.2.3 处理string对象中的字符</strong></h3><p><strong>cctype 头文件</strong>中有下列标准库函数来处理 string 中的字符。</p><p>C++语言中，字符串字面值并不是stirng对象。</p><p>下面这些函数的输入和返回值实际都是 int 类型的，且<strong>输入的值 c 必须满足 -1&lt;&#x3D;c&lt;&#x3D;255</strong>，<strong>即输入必须是 ASCII 字符。</strong></p><table><thead><tr><th></th><th>cctype头文件（ctype.h）中的函数（不需要背，学一遍知道有就可以了）</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>如果c是字母或数字，该函数返回true</td></tr><tr><td>isalpha(c)</td><td>如果c是字母，该函数返回真</td></tr><tr><td>iscntrl(c)</td><td>如果c是控制字符，该函数返回true</td></tr><tr><td>isdigit(c)</td><td>如果c是数字（0～9），该函数返回true</td></tr><tr><td>isgraph(c)</td><td>如果c是除空格之外的打印字符，该函数返回true</td></tr><tr><td>islower(c)</td><td>如果c是小写字母，该函数返回true</td></tr><tr><td>isprint(c)</td><td>如果c是打印字符（包括空格），该函数返回true</td></tr><tr><td>ispunct(c)</td><td>如果c是标点符号，该函数返回true</td></tr><tr><td>isspace(c)</td><td>如果c是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true</td></tr><tr><td>isupper(c)</td><td>如果c是大写字母，该函数返回true</td></tr><tr><td>isxdigit(c)</td><td>如果c是十六进制的数字，即0～9、a<del>f、A</del>F，该函数返回true</td></tr><tr><td>tolower(c)</td><td>如果c是大写字符，则返回其小写，否则返回该参数</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，则返回其大写，否则返回该参数</td></tr></tbody></table><p>建议：使用 c++ 版本的标准库头文件，即 cname 而非 name.h 类型的头文件。cname 头文件中的名字都从属于命名空间 std；</p><p><strong>范围for语句</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)         <span class="comment">// 对于str中的每个字符</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure><p>当要改变 string 对象中的值时，需要把循环变量定义成<strong>引用类型</strong>。必须通过显示添加 &amp; 符号来声明引用类型。</p><p>不能在范围 for 语句中改变所遍历序列的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:str)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);     <span class="comment">// 转换为大写</span></span><br></pre></td></tr></table></figure><p>对 string 的最后一个字符进行索引：s[s.size()-1];</p><p>索引必须大于等于 0 小于 size，使用索引前最好用 if(!s.empty()) 判断一下字符串是否为空。</p><p>任何表达式只要是整型值就可以作为索引。索引是无符号类型 size_type；</p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a><strong>3.3 标准库类型vector</strong></h2><p>vector：对象的集合<br>vector是模板，由vector生成的模板必须包含vector中元素的类型<br>例如vector<int>、vector&lt;vector<int> &gt;<br>引用不是对象，所以不存在包含引用的vector</p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a><strong>3.3.1 定义和初始化vector对象</strong></h3><p>vector 默认初始化为一个空 vector。</p><table><thead><tr><th></th><th>更多操作<strong>初始化<strong><strong>vector</strong></strong>对象的方法</strong></th></tr></thead><tbody><tr><td>vector<T> v1</td><td>v1是一个空vector，它潜在的元素是T类型的，指向默认初始化</td></tr><tr><td>vector<T> v2(v1)</td><td>v2中包含有v1所有元素的副本</td></tr><tr><td>vector<T> v2 &#x3D; v1</td><td>等价于v2(v1)</td></tr><tr><td>vector<T> v3(n,val)</td><td>v3包含n个重复个元素，每个元素的值都是val</td></tr><tr><td>vector<T> v4(n)</td><td>v4包含了n个重复地执行了值初始化的对象</td></tr><tr><td>vector<T> v5{a,b,c…}</td><td>v5包含了初始值个数的元素，每个元素都被赋予相应的初始值</td></tr><tr><td>vector<T> v5&#x3D;{a,b,c…}</td><td>等价于vector<T> v5{a,b,c…}</td></tr></tbody></table><p><strong>值初始化</strong></p><p><strong>值初始化的方式：</strong>如果对象是内置类型，则初始值为 0，如果是类类型，则由类默认初始化。</p><p><strong>列表初始化</strong></p><p>使用花括号一般表示列表初始化：初始化过程会尽量把花括号内的值当作一个初始值列表来处理。</p><p>如果花括号内的值不能用来列表初始化，比如对一个 string 的 vector 初始化，但是花括号内的值为整型，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v &#123;<span class="number">10</span>&#125;;        <span class="comment">// v 有 10 个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v &#123;<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>&#125;;  <span class="comment">// v 有 10 个值为 &quot;hi&quot; 的元素</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a><strong>3.3.2 向vector对象中添加元素</strong></h3><p>vector可以高效增长，通常先定义一个空 vector，然后在添加元素会更快速。</p><p>定义 vector 时，已知 vector 的大小，如果初始值都一样，初始化时确定大小与值会更快。如果初始值不全一样，即使已知大小，最好也先定义一个空的 vector，再添加元素。</p><h3 id="3-3-3-其他vector操作"><a href="#3-3-3-其他vector操作" class="headerlink" title="3.3.3 其他vector操作"></a><strong>3.3.3 其他vector操作</strong></h3><table><thead><tr><th></th><th><strong>Vector****支持的操作</strong></th></tr></thead><tbody><tr><td>v.empty()</td><td>如果v不含有任何元素，返回阵：否则返回假</td></tr><tr><td>v.size()</td><td>返回v中元素的个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾端添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 &#x3D; v2</td><td>用v2中元素的拷贝替换v1中的元素</td></tr><tr><td>v1 &#x3D; {a,b,c…}</td><td>用列表中元素的拷贝替换v1中短时</td></tr><tr><td>v1 &#x3D;&#x3D; v2</td><td>v1、v2相等当且仅当他们的元素数量相同且对应位置的元素值都相同</td></tr><tr><td>v1 !&#x3D; v2</td><td>同上</td></tr><tr><td>&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;</td><td>以字典顺序进行比较</td></tr></tbody></table><p>可以用范围 for 语句处理 vector 序列的元素</p><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a><strong>3.4 迭代器介绍</strong></h2><p>类似指针<br>使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素。<br>有迭代器的类型都拥有begin和end成员<br>        begin：返回指向第一个元素（或字符）的迭代器<br>        end：尾后迭代器，即尾元素的下一个位置（一个本不存在的元素）</p><p>所有标准库容器都可以使用迭代器</p><h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a><strong>3.4.1 使用迭代器</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();    <span class="comment">//b和e的类型相同</span></span><br><span class="line"><span class="keyword">auto</span> d = v.<span class="built_in">cbegin</span>(); f = v.<span class="built_in">cend</span>();  <span class="comment">// 返回的是const_iterator</span></span><br></pre></td></tr></table></figure><p>如果容器为空，则 begin 和 end 返回的都是尾后迭代器</p><table><thead><tr><th></th><th><strong>标准容器迭代器的运算符</strong></th></tr></thead><tbody><tr><td>*iter</td><td>返回迭代器iter所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td></tr><tr><td>++iter</td><td>令iter指示容器中的下一个元素(尾后迭代器除外)</td></tr><tr><td>–iter</td><td>令iter指示容器中的上一个元素</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>如果两个迭代器指示的是同一个元素则相等，否则不等。</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>同上</td></tr></tbody></table><p>尾后迭代器 并不实际指示某一个元素，所以不能对其进行递增或解引用</p><p>拥有迭代器的标准类型使用iterator和const_iterator（和常量指针差不多）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure><p>  迭代器类型：<br>拥有迭代器的标准类型使用iterator和const_iterator（和常量指针差不多）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">//it能读写vector&lt;int&gt;元素</span></span><br><span class="line">string::iterator it2; <span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3; <span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4; <span class="comment">//it4只能读元素，不能写元素</span></span><br></pre></td></tr></table></figure><p>如果对象是常量，begin和end返回const_iterator,否则返回iterator：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>(); <span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>(); <span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>有时候我们希望即使对象不是常量，我们也要使用const_iterator：<br>C++11新标准引入了cbegin和cend：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>(); <span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>结合解引用的成员访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">(*it).<span class="built_in">empty</span>();</span><br><span class="line">*it.<span class="built_in">empty</span>();  <span class="comment">//错误：试图访问it的名为empty的成员，但it是迭代器</span></span><br><span class="line">it-&gt;<span class="built_in">empty</span>(); <span class="comment">//箭头运算符：把解引用和成员访问两个操作合在一起</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">vector&lt;string&gt; <span class="title">text</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;hello the world!!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = text.<span class="built_in">cbegin</span>(); it != text.<span class="built_in">cend</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it)</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125; <span class="comment">//将输出三行hello the world!!</span></span><br></pre></td></tr></table></figure><p>任何一种可能改变vector对象容量的操作，都会使得对于的迭代器失效</p><h3 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a><strong>3.4.2 迭代器运算</strong></h3><p>string 和 vector 支持的迭代器运算。注意不能将两个迭代器相加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter+n </span><br><span class="line">iter-n</span><br><span class="line">iter1 + = n</span><br><span class="line">iter1 – = n</span><br><span class="line">iter1 – iter2</span><br><span class="line">&gt;、&gt;=、&lt;、&lt;=</span><br></pre></td></tr></table></figure><p>​       可以令迭代器和一个整数相加（或相减），其返回值是向前（或向后）移动了若干位置的迭代器。</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a><strong>3.5 数组</strong></h2><p>数组：复合类型（声明形如：a[d]）<br>        a：数组名称<br>        d：元素个数（必须是常量表达式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *parr[sz];</span><br><span class="line">string bad[cnt]; <span class="comment">//错误：cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()]; <span class="comment">//当get_size是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure><p>​constexpr只限制只读，并不要求在编译时就确定，可以在运行时确定。只有编译时constexpr才可以表示数组大小</p><h3 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1 定义和初始化内置数组"></a><strong>3.5.1 定义和初始化内置数组</strong></h3><p>不存在引用数组<br>可以使用列表初始化，但必须指定数组类型，不允许使用auto</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//自动推断元素个数为3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//等价于a3[] = &#123;0,1,2,0,0&#125;</span></span><br><span class="line">string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>&#125;; <span class="comment">//等价于a4[]=&#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//错误：初始值过多</span></span><br></pre></td></tr></table></figure><p>字符数组的特殊性：字符串字面值的结尾处还有一个空字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;; <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//列表初始化，含有显示的空字符</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>; <span class="comment">//含有空字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Danial&quot;</span>; <span class="comment">//错误，没有空间存放空字符！</span></span><br></pre></td></tr></table></figure><p>不能用数组为另一个数组赋值或拷贝。可以按元素一个一个拷贝，但<strong>不能直接拷贝整个数组</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a; <span class="comment">//初始化时拷贝错误</span></span><br><span class="line">a2 = a; <span class="comment">//赋值错误</span></span><br></pre></td></tr></table></figure><p>按照由内向外的顺序理解数组的类型                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">//ptrs是含有10个元素（整型指针）的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>]; <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;Parray)[<span class="number">10</span>] = arr; <span class="comment">//Parray引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//arry是数组的引用，该数组包含10个指</span></span><br></pre></td></tr></table></figure><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a><strong>3.5.2 访问数组元素</strong></h3><p>数组下标通常用 size_t 类型</p><p>使用范围 for 语句遍历数组元素</p><h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a><strong>3.5.3 指针和数组</strong></h3><p>使用数组的时候，编译器一般会把它转换成指针</p><p>指向数组元素的指针等价于 vector 中的迭代器</p><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a><strong>3.5.4 C风格字符串</strong></h3><p>c++ 支持 c 风格字符串，但是最好不要使用，c 风格字符串使用不便，并且极易引发程序漏洞</p><p>c 风格字符串不是一种类型，而是一种<strong>写法</strong>，是为了表达和使用字符串而形成的一种约定俗成的写法。</p><p>用这种写法书写的字符串存放在字符数组中并以<strong>空字符（’\0’）</strong>结束。</p><p><strong>c 风格字符串函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(p);       <span class="comment">// 返回 p 的长度，不包括空字符</span></span><br><span class="line"><span class="built_in">strcmp</span>(p1, p2);  <span class="comment">// 比较 p1 与 p2，如果 p1 大于 p2，返回一个正值，如果相等返回 0，否则返回负值。</span></span><br><span class="line"><span class="built_in">strcat</span>(p1, p2);  <span class="comment">// 把 p2 附到 p1 之后，并返回 p1</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1, p2);  <span class="comment">// 把 p2 拷贝给 p1，返回 p1</span></span><br></pre></td></tr></table></figure><p>​         </p><p>这些函数都不验证参数。传入参数的指针必须指向以空字符结束的数组。必须确保数组足够大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[] = &#123;<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;  <span class="comment">// 使用列表定义的都没有空字符</span></span><br></pre></td></tr></table></figure><p>对于 string，可以使用 s &#x3D; s1 + s2，s1 &gt; s2 等加和与比较，而 c 风格字符串不行，因为他们实际上是指针。</p><h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a><strong>3.5.5 与旧代码的接口</strong></h3><p><strong>string对象和C风格字符串的混用</strong></p><p>可以使用字符串字面值来初始化 string 对象或与 string 对象加和，所有可以用字符串字面值的地方都可以使用以空字符结束的字符数组来代替。</p><p>反过来不能使用 string 对象初始化字符数组，必须要用 <strong>c_str()</strong> 函数将 string 对象转化为 c 风格字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cp = s.<span class="built_in">c_str</span>();  <span class="comment">// s.c_str() 返回一个指向以空字符结束的字符数组的指针。</span></span><br></pre></td></tr></table></figure><p><strong>使用数组初始化 vector 对象</strong></p><p>可以使用数组来初始化 vector 对象，用两个指针来表明范围（左闭合区间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(arr), end(arr))</span></span>;</span><br></pre></td></tr></table></figure><p><strong>建议不要使用 c 风格字符串和内置数值，都使用标准库容器</strong></p><h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a><strong>3.6 多维数组</strong></h2><p>严格来说 C++ 中没有多维数组，那实际是数组的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 将所有元素初始化为 0</span></span><br></pre></td></tr></table></figure><p><strong>多维数组的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;显式初始化所有元素&#x27;</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;<span class="comment">//上面这两种方式效果是一样的</span></span><br><span class="line"><span class="string">&#x27;显式初始化部分元素&#x27;</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125; &#125;;<span class="comment">//将第一行第一个元素和第二行第一、二个元素初始化为1,4,5，其他元素执行值初始化。</span></span><br></pre></td></tr></table></figure><p><strong>多维数组的下标引用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>];<span class="comment">//这是一个有三个元素的一维数组</span></span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//第一行第一列的元素</span></span><br></pre></td></tr></table></figure><p><strong>使用范围 for 语句处理多维数组</strong></p><p>新标准中可以使用范围 for 语句处理多维数组。</p><p>注意范围 for 语句中改变元素值要显示使用 &amp; 符号声明为引用类型。</p><p>注意：使用范围 for 循环处理多维数组时，<strong>除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</strong>。</p><p>因为如果不声明为引用类型，编译器会自动将控制变量转换为指向数组首元素的指针，就不能在内层继续使用范围 for 循环处理该控制变量了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; row : arr)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure><p><strong>使用 3 种方式来输出 arr 的元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范围 for 语句-不使用类型别名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] : arr)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col : row)</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 范围 for 语句-使用类型别名</span></span><br><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (int_array &amp;p : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q : p)</span><br><span class="line">        cout &lt;&lt; q &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 普通 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">        cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> (*row)[<span class="number">4</span>] = arr; row != arr + <span class="number">3</span>; ++row)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col)</span><br><span class="line">        cout &lt;&lt; *col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>​      </p>]]></content>
    
    
    <summary type="html">一个笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记之变量和基本类型</title>
    <link href="http://1921430580.github.io/undefined/54e122cb/"/>
    <id>http://1921430580.github.io/undefined/54e122cb/</id>
    <published>2022-04-21T08:43:07.000Z</published>
    <updated>2022-04-29T00:39:23.312Z</updated>
    
    <content type="html"><![CDATA[<p>问题</p><ol><li>指针和引用有4点不同，分别是哪些？</li><li>const 对象必须怎样</li><li>const 对象的作用范围</li><li>什么是常量引用，如何声明，是顶层还是底层</li><li>常量引用与常量对象、非常量对象的关系。</li><li>什么是常量指针，如何声明，是顶层还是底层</li><li>常量指针与常量对象、非常量对象的关系。</li><li>顶层 const 和底层 const 都是什么，在什么位置</li><li>如何区分顶层 const 和底层 const</li><li>constexpr 是什么，特点是什么</li></ol><p>回答</p><ol><li>指针是对象而引用不是；指针可以重定向引用不可以；有指向指针的指针无引用的引用；引用必须初始化指针不需要</li><li>必须初始化</li><li>默认范围是文件内</li><li>不能改变对象的引用是常量引用，const int&amp; i &#x3D; a，是底层 const</li><li>不能用非常量引用绑定常量对象，可以用常量引用绑定非常量对象。</li><li>常量指针表明指针是个常量，其内存储的地址不能改变，但是指针还能修改所指对象的值。int* const p &#x3D; a，是顶层const。</li><li>可以用常量指针指向非常量对象。</li><li>顶层 const 表示指针本身是常量，底层 const 表示所指对象是常量<strong>。顶层 const 在右边，底层 const 在左边</strong></li><li>只有指针同时有顶层和底层，const 在星号右边是顶层，左边是底层。引用的 const 是底层，其他类型 const 是顶层。</li><li>常量表达式。两个点：值不能改变、在编译阶段就可以计算出值</li></ol><p>问题</p><ol><li>浮点数赋给整型变量时如何舍入？</li><li>decltype 是什么，如何使用</li><li>如何声明而非定义一个变量</li><li>如果指针不初始化会有什么影响</li><li>如何在多个文件间共享 const 对象</li><li>使用 auto 来定义引用时要注意什么</li><li>预处理变量的作用范围是什么</li><li>C++属于静态类型语言，静态类型语言的含义是什么？</li><li>C++有两种定义类型别名的方式，分别是什么</li></ol><p>回答</p><ol><li>只保留小数点前的部分，即向零舍入</li><li>用来获取变量类型，decltype(c) a;</li><li>使用 extern 修饰符： extern int i:</li><li>在块作用域中，未初始化的指针的值是未定义的。</li><li>如果想在多个文件间共享const对象，必须在变量的定义前添加extern关键字并在本文件中声明。声明和定义都要加extern</li><li>用 auto 定义引用时，必须要加 &amp; 符号。尤其是在范围 for 循环中，当想要修改值时，一定要记得加上引用符。</li><li>文件内。</li><li>静态类型语言在编译时检查变量类型。</li><li>typedef unsigned int size_type 和 using size_type &#x3D; unsigned int;</li></ol><h1 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h1><p>​C++定义了几种基本内置类型，如字符、整型、浮点数等。</p><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><p>​基本内置类型包括算数类型和空类型。算数类型包括字符、整型数、浮点数和布尔值。</p><h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 算术类型</h3><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center">c++算数类型</th></tr></thead><tbody><tr><td align="center"><strong>类型</strong></td><td align="center"><strong>含义</strong></td><td align="center"><strong>最小尺寸</strong></td><td align="center"><strong>说明</strong></td></tr><tr><td align="center">bool</td><td align="center">布尔类型</td><td align="center">未定义</td><td align="center">取值为真（true）或假（false）</td></tr><tr><td align="center">char</td><td align="center">字符</td><td align="center">8位</td><td align="center">1个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值</td></tr><tr><td align="center">wchar_t</td><td align="center">宽字符</td><td align="center">16位</td><td align="center">用于扩展字符集，确保可以存放机器最大扩展字符集中的任意一个字符</td></tr><tr><td align="center">char16_t</td><td align="center">Unicode字符</td><td align="center">16位</td><td align="center">用于扩展字符集，为 Unicode 字符集服务</td></tr><tr><td align="center">char32_t</td><td align="center">Unicode字符</td><td align="center">32位</td><td align="center">用于扩展字符集，为 Unicode 字符集服务</td></tr><tr><td align="center">short</td><td align="center">短整型</td><td align="center">16位</td><td align="center"></td></tr><tr><td align="center">int</td><td align="center">整型</td><td align="center">16位</td><td align="center">一个 int 至少和 一个 short 一样大</td></tr><tr><td align="center">long</td><td align="center">长整形</td><td align="center">32位</td><td align="center">一个 long 至少和一个 int 一样大</td></tr><tr><td align="center">long long</td><td align="center">长长整形</td><td align="center">64位</td><td align="center">C++11 中新定义，一个 long long 至少和 一个 long 一样大</td></tr><tr><td align="center">float</td><td align="center">浮点型</td><td align="center">6位有效数字</td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">双精度浮点型</td><td align="center">10位有效数字</td><td align="center"></td></tr><tr><td align="center">long double</td><td align="center">扩展精度浮点型</td><td align="center">10位有效数字</td><td align="center">常常用于有特殊浮点需求的硬件</td></tr></tbody></table><p>​计算机以比特序列存储数据，每个比特非0即1,<br>​可寻址的最小内存块称为“字节（byte）”，内存的基本单元称为“字（word）”<br>​大多数机器的字节由8比特构成，字则由32或64比特构成</p><ul><li>无符号类型<br>int、short、long和long long都是带符号的，前面加上unsigned就可以得到无符号类型，例如unsigned long<br>unsigned int可以缩写成unsigned。<br>char比较特殊，类型分为三种：char、signed char、unsigned char<br>char是signed char或unsigned char的其中一种（编译器决定）</li></ul><p>c++字符类型选择：</p><p>​明确知晓数值不可能为负时，选用无符号类型。</p><p>​整数运算用 int，数值太大时用 long long，不用 short 和 long</p><p>​浮点数运算用 double。float 和 double 的计算代价相差无几</p><h3 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h3><p>几种类型转换的情况：</p><ol><li>把浮点数赋给整型时，结果仅保留小数点前的部分。</li><li>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1&#x3D;256*(-1)+255）</li><li>赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="number">42</span>;        <span class="comment">//b为真</span></span><br><span class="line"><span class="type">int</span> i=b;    <span class="comment">//i的值为1</span></span><br><span class="line">i=<span class="number">3.14</span>;        <span class="comment">//i的值为3</span></span><br><span class="line"><span class="type">double</span> pi=i;    <span class="comment">//pi的值为3.0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c=<span class="number">-1</span>;    <span class="comment">//假设char占8比特，c的值为255</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2=<span class="number">256</span>;    <span class="comment">//假设char占8比特，c2的值未定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。</li><li>含有无符号类型的表达式</li><li>个表达式中既有无符号数又有int值时，int会被转换成无符号数。</li><li>无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模，切勿混用带符号类型和无符号类型。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">-42</span>;</span><br><span class="line">std::cout &lt;&lt; i+i &lt;&lt; std::endl;<span class="comment">//输出-84</span></span><br><span class="line">std::cout &lt;&lt; u+i &lt;&lt; std::endl;<span class="comment">//如果int占32位，输出4294967264</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h3><p>​一个型如42的值就称为字面值常量（literal）</p><p>​整型和浮点型字面值</p><p>​整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。</p><p>​整型字面值的具体数据类型由它的值和符号决定。默认情况下十进制字面值是带符号数，类型是 int, long, long long 中能容纳当前值的尺寸最小的那个。</p><p>​浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span> <span class="number">3.14169E0</span> <span class="number">0.</span> <span class="number">0e0</span> <span class="number">.001</span></span><br></pre></td></tr></table></figure><p>字符和字符串字面值</p><p>​单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。</p><p>​字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（’\0’），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。</p><p>​如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写。</p><p>​                “A is B”   “and B is A”; &#x2F;&#x2F;两个字符串实际上是一个整体。              </p><p>转义序列</p><p>C++ 定义的转义序列包括：</p><p><img src="D:\blog\source_posts\c-笔记之基本类型\转义字符.png" alt="转义序列"></p><p>在程序中，上述转义序列被当作一个字符使用。</p><p>也可以使用泛化的转移序列，形式是 \后跟 1~3 个八进制数字或 \x 后跟 1 个或多个十六进制数字。</p><p>​          <img src="D:\blog\source_posts\c-笔记之基本类型\泛化的转义序列.png" alt="泛化的转义序列">    </p><p>指定字面值的类型</p><p>可以通过给字面值增加前缀和后缀来改变字面值的默认类型。</p><p>   <img src="D:\blog\source_posts\c-笔记之基本类型\字符和字符串字面值.png" alt="常用字符和字符串字面值"></p><p>注意 12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f。         </p><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>对于c++而言，”变量“和”对象“一般可以互换使用。</p><p>c++中，对象通常指一块能存储数据并具有某种类型的内存</p><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><p>● 变量提供一个具有名称的、可供程序操作的存储空间。<br>● 变量都具有数据类型，通过数据类型可以决定变量所需要的内存空间、布局方式、以及能够表示值的范围</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">0</span>,value,<span class="comment">//sum、value和unit_sold都是int</span></span><br><span class="line">units_sold=<span class="number">0</span>;<span class="comment">//sum和units_sold初值为0</span></span><br><span class="line">Sales_item item;<span class="comment">//item的类型是Sales_item     </span></span><br><span class="line"><span class="comment">//string 是一种库类型，表示一个可变长的字符序列</span></span><br><span class="line"><span class="function">std::string <span class="title">book</span><span class="params">(<span class="string">&quot;0-2-1-78345-X&quot;</span>)</span></span>;<span class="comment">//book通过一个string字面值初始化</span></span><br></pre></td></tr></table></figure><p>注：对于我们自己定义的类型item，我们希望自己定义的类型和它内置的类型用法上是接近的。最好是一样，这样我们的学习成本比较低可以直接拿过来使用。</p><p>初始化</p><p>​可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。       </p><p>​初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值擦除并用一个新值来替代。</p><p>​下面四种初始化方式都是可行的，其中使用花括号的方式叫做列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;;<span class="comment">//列表初始化 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>​当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;<span class="comment">//错误：转换未执行，因为存在丢失信息的风险</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>,d</span>=ld;<span class="comment">//正确：转换执行，且确实丢失了部分值</span></span><br></pre></td></tr></table></figure><p>默认初始化</p><p>●  如果定义变量没有定义初始值，则变量被赋予默认值。<br>●  默认值是由变量类型决定的，同时定义变量的位置也会有影响。<br>    ●  内置类型：由定义的位置决定，函数体之外初始化为0，函数体内不初始化。<br>    ●  每个类各种决定其初始化对象的方式</p><p>类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std:::string empty;<span class="comment">//empty非现实地初始化一个空串</span></span><br><span class="line">Sales_item item;<span class="comment">//被默认初始化的Sales_item对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未初始化的变量含有一个不确定的值，将带来无法预计的后果，应该避免。建议初始化每一个内置类型的变量。</p><h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><p>Q：变量声明和定义的区别</p><p>A：为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。</p><p>​说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。</p><p>​c++是一种静态类型语言，其含义是在编译阶段检查类型。这就要求我们在使用某个变量之前必须先声明。<br>​如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显示的初始化，任何包含了显式初始化的声明即成为定义。声明变量不能赋值。例：extern int i &#x3D; 1; &#x2F;&#x2F; 定义 i，初始化抵消了 extern 的作用。</p><p>​extern不是定义，是引入(声明)在其它源文件中定义的非static全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.14</span>;<span class="comment">//定义,不能放在函数体内部</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;<span class="comment">//声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j;<span class="comment">//声明并定义j</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>变量只能被定义一次，但是可以多次声明。</p><h3 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h3><p>标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。</p><p>名字的作用域</p><p>​同一个名字如果出现在程序的不同位置，也可能指向不同的实体。<br>​C++中大多数作用域都以花括号分隔。<br>​名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p><p><img src="C:\Users\张\AppData\Roaming\Typora\typora-user-images\image-20220422150135299.png" alt="image-20220422150135299"></p><p>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p><p>2.3 复合类型</p><p>复合类型就是基于其他类型定义的类型，引用和指针是其中两种。</p><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><p>引用是为对象起的另一个名字定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用引用本身并不是对象，所以不能定义引用的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;<span class="comment">//refVal指向ival(是ival的另一个名字)</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;<span class="comment">//报错：引用必须初始化</span></span><br><span class="line">refVal = <span class="number">2</span>;<span class="comment">//把2给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="type">int</span> li = refVal;<span class="comment">//等同于li=ival</span></span><br><span class="line"><span class="comment">//正确：refVal13绑定到了那个与refVal绑定的对象上，即绑定了ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">//利用与refVal绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="type">int</span> i = refVal;<span class="comment">//正确：i被初始化为ival的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用不是对象，不存在地址，所以不能定义指向引用的指针。</p><p>引用必须初始化。引用的初始值必须是一个对象，不能是字面值。</p><p>对引用的所有操作都是对与之绑定的对象的操作。      </p><p>引用只能绑定在对象上，不能与字面值或表达式绑定。</p><p>引用只能绑定同类型对象。</p><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><p>指针：对地址的封装，本身就是一个对象<br>●定义指针类型的方法是将声明符写成d的形式<br>●如果一条语句中定义了几个指针变量，每个变量前面都必须加上符号<br>●和其他内置类型一样，在块作用域内定义指针如果没有初始化，将拥有一个不确定的值</p><p>指针必须指向指定的类型，不能指向其他类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;<span class="comment">//ip1和ip2都是指向int型对象的指针</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;          </span><br></pre></td></tr></table></figure><p>指针与引用的不同：</p><ol><li>指针是一个对象而引用不是；</li><li>指针可以重定向引用不可以；</li><li>有指向指针的指针无引用的引用；</li><li>指针不需要在定义时赋初值而引用需要。</li><li>不能定义指向引用的指针。可以定义指向指针的引用。</li></ol><p>​                int p;  int &amp;r &#x3D; p;      &#x2F;&#x2F; r是对指针p的引用              </p><p>面对如上 *&amp;r 这样比较复杂的指针或引用的声明语句时，从右向左读比较易于弄清。</p><p>可以使用取地址符（操作符&amp;）获取指针所封装的地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival;<span class="comment">//p是指向ival的指针</span></span><br><span class="line"><span class="type">double</span> *dp = &amp;ival;<span class="comment">//错误：类型不匹配</span></span><br></pre></td></tr></table></figure><p>可以使用解引用符（操作符*）利用指针访问对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival;<span class="comment">//p是指向ival的指针</span></span><br><span class="line">std::cout&lt;&lt;*p ;<span class="comment">//输出42</span></span><br><span class="line">*p=<span class="number">0</span>;</span><br><span class="line">std::cout&lt;&lt;*p; <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure><p><strong>空指针（null pointer）</strong>不指向任何对象</p><p>在使用一个指针之前，可以首先检查它是否为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">//C++11（最好使用这种方式）， NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">//需要#include cstdlib</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">p1 = zero; <span class="comment">//错误：类型不匹配           </span></span><br></pre></td></tr></table></figure><p>建议初始化所有指针。</p><p>非零指针对应的条件值是 ture，零指针对应的条件值是 false。</p><p><strong>void*指针</strong></p><p>纯粹的地址封装，与类型无关。可以用于存放任意对象的地址。</p><p>void* 指针和空指针不是一回事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure><p><strong>指向指针的指针</strong></p><p>通过*的个数可以区分指针的级别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;<span class="comment">//ppi指向一个int型的指针</span></span><br></pre></td></tr></table></figure><p><strong>指向指针的引用</strong></p><p>指针是对象，可以定义引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i;<span class="comment">//r引用了一个指针，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;<span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><p>定义复合类型的变量要比定义基本类型的变量复杂很多。</p><p>一条声明语句是由一个基本数据类型和紧随其后的声明符列表组成的。</p><p>引用符 &amp; 和指针符 * 都是类型说明符，类型说明符是声明符的一部分。</p><p>​                int &amp;a&#x3D;b, &amp;c&#x3D;b; int *a&#x3D;nullptr, b&#x3D;1;              </p><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>把变量定义成一个常量</p><p>使用const对变量的类型加以限定，变量的值不能被改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>; <span class="comment">//输入缓冲区大小</span></span><br><span class="line">bufSize = <span class="number">512</span>; <span class="comment">//错误：试图向const对象写值</span></span><br></pre></td></tr></table></figure><p>​const 对象必须初始化，因为一旦创建就不能再改变值。（其他时候不能出现在等号左边）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>(); <span class="comment">//正确：运行时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>; <span class="comment">//正确：编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k; <span class="comment">//错误：k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bb=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> * a= bb;<span class="comment">//在编译的时候，会把bb编程常量</span></span><br></pre></td></tr></table></figure><p>​默认情况下，const 对象仅在文件内有效。如果想在多个文件间共享 const 对象，必须在变量的定义前添加 extern 关键字并在本文件中声明。声明和定义都要加 extern</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//file_1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3><p>​ const 的引用：常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci; <span class="comment">//正确：引用及其绑定的对象都是常量</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//错误，相当于c1=42，试图修改常量</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;<span class="comment">//错误：ci是常量，存在通过r2改变ci（const）的风险</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i; <span class="comment">//正确：i依然可以通过其他途径修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1*<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;r4 = r1*<span class="number">2</span>; <span class="comment">//错误：不能通过一个非常量的引用指向一个常量可以用常量引用指向一个非常量对象</span></span><br></pre></td></tr></table></figure><p>​对象不必是常量。对 const 对象的引用也必须是常量。</p><p>​引用必须初始化，因此常量引用也必须初始化。</p><p>​注意引用不是对象，因此常量引用不是说引用是常量，引用本来就只能绑定一个对象，而是引用不能改变引用的对象了。</p><p>​引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p><p>​                const int &amp;r &#x3D; 42;  &#x2F;&#x2F; 常量引用可以绑定字面值              </p><p>当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。</p><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p>​指向常量的指针的用法和常量引用相似，但是是不一样的。它既可以指向常量也可以指向非常量，不能改变对象的值。但是非常量对象可以通过其他途径改变值</p><p>●指向常量的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi; <span class="comment">//错误：存在通过ptr指针修改pi的风险</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> * cptr = &amp;pi;</span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval; <span class="comment">//正确：但不能通过cptr修改dval的值</span></span><br></pre></td></tr></table></figure><p>const指针：指针是对象，也可以限定为常量（必须初始化）<br>        把*放在const之前，说明指针是一个常量<br>        不变的是指针本身的值，而非指向的那个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;<span class="comment">//指向常量的常量指针</span></span><br><span class="line"></span><br><span class="line">*pip = <span class="number">2.71</span>;<span class="comment">//错误： 试图修改常量pi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*curErr)&#123;</span><br><span class="line"> <span class="built_in">errorHandler</span>();</span><br><span class="line"> *curErr = <span class="number">0</span>; <span class="comment">//正确：试图修改变量errNumb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><p>​顶层 const 表示指针本身是个常量，底层 const 表示指针所指的对象是一个常量。顶层 const 对任何数据类型通用，底层 const 只用于引用和指针。顶层 const 的指针表示该指针是 const 对象，因此必须初始化。底层 const 的指针则不用。</p><p>​实际上只有指针类型既可以是顶层 const 也可以是底层 const，因为引用实际上只能是底层 const，常量引用即为底层 const，不存在顶层 const 的引用。            </p><p>​从右向左读来判断是顶层 const 还是底层 const。</p><p>​对于指针和引用而言，顶层 const 在右边，底层 const 在左边。对于其他类型，全都是顶层 const</p><p>​执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">//顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>; <span class="comment">//顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 =  &amp;ci;<span class="comment">//底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;<span class="comment">//（左：底层 ）， （右：顶层）</span></span><br><span class="line"></span><br><span class="line">i = ci;<span class="comment">//正确</span></span><br><span class="line">p2 = p3;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = p3;<span class="comment">//错误：存在通过*p修改*p3（const）的风险</span></span><br><span class="line">p2 = &amp;i;  <span class="comment">//正确：只是不能通过p2修改i而已</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci; <span class="comment">//错误：存在通过r修改ci（const)的风险</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i; <span class="comment">//正确：只是不能通过r2修改i而已</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-4-constexpr和常量表达式（const-expression）"><a href="#2-4-4-constexpr和常量表达式（const-expression）" class="headerlink" title="2.4.4 constexpr和常量表达式（const expression）"></a>2.4.4 constexpr和常量表达式（const expression）</h3><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p>字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>; <span class="comment">//是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files +<span class="number">1</span>; <span class="comment">//是</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>; <span class="comment">//不是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">//不是         </span></span><br></pre></td></tr></table></figure><p>cosntexpr变量</p><p>C++11标准规定，允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量表达式。<br>        一定是一个常量<br>        必须用常量表达式初始化</p><p>需要在编译时就得到计算，声明constexpr时用到的类型必须显而易见，容易得到（称为：字面值类型）。自定义类型（例如：Sales_item）、IO库、string等类型不能被定义为constexpr</p><p>​cosntexpr 指针的初始值必须是 nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">//只有当size是一个constexpr函数时才正确</span></span><br></pre></td></tr></table></figure><p>指针和constexpr<br>        限定符仅对指针有效，对指针所指的对象无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *np = <span class="literal">nullptr</span>; <span class="comment">//常量指针</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p = &amp;i; <span class="comment">//p是常量指针，指向常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p1 = &amp;j; <span class="comment">//p1是常量指针，指向变量j</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意区分 constexpr 和 const 。constexpr 都是顶层 const，仅对指针本身有效。         </p><p><strong>区分const和constexpr</strong></p><p>constexpr 限定了变量是编译器常量，即变量的值在编译器就可以得到。</p><p>const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。</p><p>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</p><h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><p>随着程序越来越复杂，程序中的变量也越来越复杂。<br>        拼写变得越来越困难。<br>        搞不清楚变量到底需要什么类型。</p><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p>作用：提高程序可读性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; </span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base是double的同义词，p是double *的同义词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//C++11,别名声明</span></span><br><span class="line">wages hourly, weekly; </span><br><span class="line">SI item; <span class="comment">//等价于Sales_item item</span></span><br></pre></td></tr></table></figure><p>对于指针这样的复合类型，类型别名的使用可能会产生意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps; <span class="comment">//ps是指针变量，它的对象是指向char的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">//是对const pstring cstr =0 的错误理解</span></span><br></pre></td></tr></table></figure><p>有两种方法定义类型别名。</p><p>​                typedef double wages;  &#x2F;&#x2F; 使用 typedef 关键字 </p><p>using wages &#x3D; double;  &#x2F;&#x2F; 使用 using 关键字进行别名声明              </p><p>typedef 作为声明语句中的基本数据类型的一部分出现。含有 typedef 的声明语句定义的不再是变量而是类型别名。和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造符合类型。</p><p>​                typedef wages base, p; &#x2F;&#x2F; base 是 double 的别名，p 是 double 的别名。              </p><p>指针、常量和类型别名</p><p>​                typedef char* pstring;  const pstring cstr &#x3D; 0; &#x2F;&#x2F; 注意：const 是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr &#x3D; 0，这是错误的。              </p><h3 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h3><p>auto 说明符让编译器根据初始值来分析表达式所属的类型。理解：使用 auto 会增加编译时间，但不会增加运行时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i =<span class="number">0</span>, *p = &amp;i; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>; <span class="comment">//错误：auto已经被推断为int型，却需要被推断为double型</span></span><br></pre></td></tr></table></figure><p>auto 可以在一条语句中声明多个变量，但是多个变量必须是同一个基本数据类型（整型与整型指针和整型引用算一个类型）。</p><p>复合类型、常量和auto</p><p>编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：</p><ol><li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li><li>auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。</li><li>auto 会保留底层 const。</li></ol><p>概括一下就是 auto 会忽略引用与顶层 const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">//a是int型</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">//b是int型，ci的顶层const被忽略</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">//c是int型，ci的顶层const被忽略</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">//d是整形指针，整数的地址就是指向整形的指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">//e是指向整数常量的指针（底层const没有被忽略）</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci; <span class="comment">//auto的推演类型为 int，f是const int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">//g是一个整形常量引用，绑定到ci，（底层const没有被忽略）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>; <span class="comment">//错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j =<span class="number">42</span>; <span class="comment">//正确：可以为常量引用绑定字面值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> k = ci, &amp;l = i; </span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = &amp;ci;</span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci; <span class="comment">//错误：类型不一致</span></span><br></pre></td></tr></table></figure><p>int 与 int *、int &amp; 是一个基本数据类型，而 const int 与 int 不是一种类型。</p><p>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用。</p><h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><p>当希望获得表达式的类型但是不要值的时候，可以使用类型说明符 decltype。</p><p>如果 decltype 使用的表达式是一个变量，则它返回该变量的类型（包括顶层 const 和引用在内）。</p><p>decltype 与 auto 的不同：decltype 不会忽略引用和顶层 const。</p><p>注意当获得的类型是引用时，必须初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;<span class="comment">// sum的类型就是函数f返回的类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y的类型是const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">//错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure><p>引用从来都是作为对象的别名出现，只有在 decltype 处是例外。</p><p>decltype 和引用</p><p>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。可以使用这种方式来保证不获取引用类型。</p><p>注意：如果表达式的内容是解引用操作，则decltype将得到引用类型。给变量加括号的结果也是引用类型。赋值操作的结果也是引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b; <span class="comment">//正确：b为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：下面的*不是出现在声明中，而是表达式中的解引用运算符</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误：解引用表达式，c的类型为引用，需要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量如果是加上括号， decltype的结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>( (i) ) d; <span class="comment">//错误：d是int&amp;类型,必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>( ( (i) ) ) d1 = i; <span class="comment">//正确：d1是int&amp;类型，绑定为了i</span></span><br><span class="line"><span class="keyword">decltype</span>( i ) e; <span class="comment">//正确：e是一个（未初始化的）int           </span></span><br></pre></td></tr></table></figure><p>decltype((var)) 的结果永远是引用，而 decltype(var) 的结果只有当 var 本身就是引用时才是引用。</p><h2 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h2><p>一组数据以及相关操作的集合</p><h3 id="2-6-1-定义sales-data类型"><a href="#2-6-1-定义sales-data类型" class="headerlink" title="2.6.1 定义sales_data类型"></a>2.6.1 定义sales_data类型</h3><p>类定义：类定义可以使用关键字class或struct<br>        二者默认的继承访问权限不同<br>        struct是public的，class是private的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"> std::string bookNo;</span><br><span class="line"> <span class="type">unsigned</span> units_sold = <span class="number">0</span>; <span class="comment">//C++ 11</span></span><br><span class="line"> <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;<span class="comment">//类定义的最后需要加上分号</span></span><br></pre></td></tr></table></figure><p>数据成员定义了类的对象的具体内容，每个对象有自己的一份拷贝。</p><p>struct+类名+类体+分号。类体可以为空。</p><p>​                struct Sales_data{};   &#x2F;&#x2F; 注意：结尾加分号              </p><p>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。</p><p>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p><p>类使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Sales_data data1, data2;</span><br><span class="line"><span class="type">double</span> price = <span class="number">0</span>;  <span class="comment">// 书的单价, 用于计算总收入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取第1条交易记录: ISBN, number of books sold, price per book</span></span><br><span class="line">std::cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;</span><br><span class="line"><span class="comment">// calculate total revenue from price and units_sold</span></span><br><span class="line">data1.revenue = data1.units_sold * price;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取第2条交易记录:</span></span><br><span class="line">std::cin &gt;&gt; data2.bookNo &gt;&gt; data2.units_sold &gt;&gt; price;</span><br><span class="line">data2.revenue = data2.units_sold * price;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data1.bookNo == data2.bookNo) &#123;</span><br><span class="line"><span class="type">unsigned</span> totalCnt = data1.units_sold + data2.units_sold;</span><br><span class="line"><span class="type">double</span> totalRevenue = data1.revenue + data2.revenue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print: ISBN, total sold, total revenue, average price per book</span></span><br><span class="line">std::cout &lt;&lt; data1.bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalCnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (totalCnt != <span class="number">0</span>)std::cout &lt;&lt; totalRevenue/totalCnt &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span> std::cout  &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// indicate success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// transactions weren&#x27;t for the same ISBN</span></span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Data must refer to the same ISBN&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// indicate failure</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span> <span class="number">10</span> <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span> <span class="number">15</span> <span class="number">70</span> <span class="number">4.66667</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-编写自己的头文件"><a href="#2-6-3-编写自己的头文件" class="headerlink" title="2.6.3 编写自己的头文件"></a>2.6.3 编写自己的头文件</h3><p>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</p><p>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。</p><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p><p>预处理器概述</p><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p><p>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。</p><p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p><p>c++ 中包含三个头文件保护符<strong>：</strong></p><ol><li>#define：把一个名字设定为预处理变量</li><li>#ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #endif 为止</li><li>#endif</li></ol><p>预处理变量无视作用域的规则，作用范围是文件内</p><p><img src="C:\Users\张\AppData\Roaming\Tencent\Users\1921430580\QQ\WinTemp\RichOle\P4BHJQ(31HASZWPEZL)0YDK.png" alt="P4BHJQ(31HASZWPEZL)0YDK"></p>]]></content>
    
    
    <summary type="html">一个简单的笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常用的十大排序算法</title>
    <link href="http://1921430580.github.io/undefined/602a3097/"/>
    <id>http://1921430580.github.io/undefined/602a3097/</id>
    <published>2022-04-21T01:17:54.000Z</published>
    <updated>2022-04-27T01:47:20.242Z</updated>
    
    <content type="html"><![CDATA[<p>待更新</p>]]></content>
    
    
    <summary type="html">更新中ing</summary>
    
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="http://1921430580.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python基础学习笔记之变量与运算</title>
    <link href="http://1921430580.github.io/undefined/403834c2/"/>
    <id>http://1921430580.github.io/undefined/403834c2/</id>
    <published>2022-04-18T07:16:54.000Z</published>
    <updated>2022-04-21T08:14:32.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、变量与运算"><a href="#一、变量与运算" class="headerlink" title="一、变量与运算"></a>一、变量与运算</h1><p>​在任何程序语言中，最基本的一项功能就是设置变量。 通过对变量的运算，来实现程序功能。</p><h2 id="1、变化的量"><a href="#1、变化的量" class="headerlink" title="1、变化的量"></a>1、变化的量</h2><p>​所谓设置一个变量，也就是设置一个可以变化的量。变量简单理解，就是我们给一个东西的名字。 或者说是为了暂时在计算机中存储一个东西，我们给这个东西取了一个名字。比如如果我们要做文件管理系统， 那么这个系统得有一个名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;文件管理系统&quot;</span></span><br></pre></td></tr></table></figure><p>​这里的 name 是我们为这个变量设置的名字，而 文件管理系统 则是这个变量 name 中的取值。</p><p>​在Python中，我们可以用三种方式来标识字符：</p><p>​第一种是用英文的单引号</p><p>​第二种是用英文的单引号</p><p>​第二种是用三个引号（可单&#x2F;双引）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;文件管理系统&#x27;</span></span><br><span class="line">name2 = <span class="string">&quot;文件管理系统&quot;</span></span><br><span class="line">name3 = <span class="string">&quot;&quot;&quot;文件管理系统&quot;&quot;&quot;</span>   <span class="comment">#或者是&#x27;&#x27;&#x27;文件管理系统&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Q：为什么要使用三个引号呢？使用三个引号有什么好处呢？</p><p>A：这种三个引号的在文本量比较多的情况下有一个好处，就是可以书写跨行的文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一段长文本，</span></span><br><span class="line"><span class="string">有多长的，</span></span><br><span class="line"><span class="string">是真的很长。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">long_text</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Q ：如果只用一个引号来写多行文本会有什么问题呢？</p><p>A：语法错误，报错内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/lib/python3.9/asyncio/futures.py&quot;</span>, line <span class="number">201</span>, <span class="keyword">in</span> result</span><br><span class="line">    <span class="keyword">raise</span> self._exception</span><br><span class="line">  File <span class="string">&quot;/lib/python3.9/asyncio/tasks.py&quot;</span>, line <span class="number">256</span>, <span class="keyword">in</span> __step</span><br><span class="line">    result = coro.send(<span class="literal">None</span>)</span><br><span class="line">  File <span class="string">&quot;/lib/python3.9/site-packages/_pyodide/_base.py&quot;</span>, line <span class="number">494</span>, <span class="keyword">in</span> eval_code_async</span><br><span class="line">    <span class="keyword">await</span> CodeRunner(</span><br><span class="line">  File <span class="string">&quot;/lib/python3.9/site-packages/_pyodide/_base.py&quot;</span>, line <span class="number">237</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self.ast = <span class="built_in">next</span>(self._gen)</span><br><span class="line">  File <span class="string">&quot;/lib/python3.9/site-packages/_pyodide/_base.py&quot;</span>, line <span class="number">141</span>, <span class="keyword">in</span> _parse_and_compile_gen</span><br><span class="line">    mod = <span class="built_in">compile</span>(source, filename, mode, flags | ast.PyCF_ONLY_AST)</span><br><span class="line">  File <span class="string">&quot;&lt;exec&gt;&quot;</span>, line <span class="number">3</span></span><br><span class="line">    long_text = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">                 ^</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></table></figure><p>在定义多个变量的时候，我们还有一些快捷写法，比如下面这样，等号两边逐个写出变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name1, name2, name3 = <span class="string">&quot;文件&quot;</span>, <span class="string">&quot;系统&quot;</span>, <span class="string">&quot;管理&quot;</span></span><br></pre></td></tr></table></figure><p>或者你想一次性定义多个相同取值的变量，有一个简单的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name1 = name2 = name3 = <span class="string">&quot;文件系统&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2、打印-Print"><a href="#2、打印-Print" class="headerlink" title="2、打印 Print"></a>2、打印 Print</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的Python最棒~&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的Python的&quot;</span>, name, <span class="string">&quot;业界顶呱呱&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我看着&quot;</span>, <span class="string">&quot;莫烦&quot;</span>, <span class="string">&quot;的教学长大的~&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、数学运算"><a href="#3、数学运算" class="headerlink" title="3、数学运算"></a>3、数学运算</h2><p>​除了文本数据，我们使用变量还可以记录多种多样的信息。比如数字和列表，字典。 这节主要讲数字和基于数字的基本运算。列表和字典我们留在后面 文件管理系统中，和数字有关的比如文件时间（在后续的datetime详细讲解）， 或者是文件版本号，文件数等。这里我们用文件数来过一遍数学运算的知识。</p><p>很简单，运用上面变量的知识，你只需要给这个数字一个名字，比如我的系统里有十个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_of_files = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我系统里有&quot;</span>, num_of_files, <span class="string">&quot;个文件&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些文件我要分成5组，每组多少个呢？这就是除法了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分五组，每组&quot;</span>, num_of_files / <span class="number">5</span>, <span class="string">&quot;个&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>3+4&#x3D;7</td></tr><tr><td>-</td><td>减</td><td>3-4&#x3D;-1</td></tr><tr><td>*</td><td>乘</td><td>3*4&#x3D;12</td></tr><tr><td>&#x2F;</td><td>除</td><td>3&#x2F;2&#x3D;1.5</td></tr><tr><td>%</td><td>取模</td><td>103%100&#x3D;3</td></tr><tr><td>**</td><td>幂</td><td>3**2&#x3D;9</td></tr><tr><td>&#x2F;&#x2F;</td><td>取整除</td><td>10&#x2F;&#x2F;3&#x3D;3</td></tr></tbody></table><p>注：字符串也是可以相加的</p><p>一些简便的运算写法：常用的及时修改变量的简便写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>        </span><br><span class="line">a += <span class="number">1</span>                <span class="comment">#相当于a=a+1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a += &quot;</span>, a)</span><br><span class="line">a -= <span class="number">1</span>                <span class="comment">#相当于a=a-1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a -= &quot;</span>, a)</span><br><span class="line">a *= <span class="number">10</span>               <span class="comment">#相当于a=a*10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a *= &quot;</span>, a)</span><br><span class="line">a /= <span class="number">2</span>                <span class="comment">#相当于a=a/2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a /= &quot;</span>, a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二、判断，数据，循环</p><p>​1、if 如果：if 很好理解，就是判断的基石，如果什么样就做什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in_trash = <span class="literal">True</span>              <span class="comment">#在回收站中</span></span><br><span class="line"><span class="keyword">if</span> in_trash:              <span class="comment">#如果在回收站中则执行下一步</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;可以被彻底删除&quot;</span>)<span class="comment">#打印可以被彻底删除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​Q：你可以尝试一下，把上面的in_trash &#x3D; True改成in_trash &#x3D; False，看看会有什么样的结果。 </p><p>​A：不打印</p><p>下面，我们在 in_trash 前面加上一个 not 来表示 in_trash 的反面，也就是不在垃圾桶里的意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in_trash = True</span><br><span class="line">if not in_trash:</span><br><span class="line">    print(&quot;不可以被彻底删除&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​同样，你可以再尝试一下，把上面的in_trash &#x3D; False改成in_trash &#x3D; True，看看会有什么样的结果。</p><p>if-else 如果否则</p><p>​其实，如果又要判断正面又要判断反面的情况，我们完全可以一次性搞定，比如下面使用 if-else 这种结构。 简单明了地就同时判断了正反面应该做的两件不同的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in_trash = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> in_trash:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;可以被彻底删除&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不可以被彻底删除&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断条件</p><p>​其实除了 True &#x2F; False 还有很多其他的间接判断条件。比如下面列出来的这些判断标准。</p><table><thead><tr><th>判断</th><th>含义</th></tr></thead><tbody><tr><td>a &#x3D;&#x3D; b</td><td>a 是否等于 b</td></tr><tr><td>a &gt; b</td><td>a 是否大于 b</td></tr><tr><td>a &gt;&#x3D; b</td><td>a 是否大于等于 b</td></tr><tr><td>a &lt; b</td><td>a 是否小于 b</td></tr><tr><td>a &lt;&#x3D; b</td><td>a 是否小于等于 b</td></tr><tr><td>a !&#x3D; b</td><td>a 是否不等于 b</td></tr></tbody></table><p>​如果是文字的话，也可以比较是否等于&#x2F;不等于，其它那些大于小于都是用于数值判断的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = &quot;文件1&quot;, &quot;文件2&quot;</span><br><span class="line">a == b</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;2 &lt; 3&quot;, 2 &lt; 3)</span><br><span class="line">print(&quot;3 &lt; 2&quot;, 3 &lt; 2)</span><br><span class="line">print(&quot;2 != 2&quot;, 2 != 2)</span><br></pre></td></tr></table></figure><p>你还可以在这里尝试大把其他的判断，这些判断都会返回一个 True 后 False 的结果。甚至，你还可以叠加不同的判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(2 &lt; 3 and 2 &lt; 5)</span><br><span class="line">print(2 &gt; 3 or 3 == 3)</span><br><span class="line">print(2 &gt; 3 or not 3 == 3 and 5 &lt; 10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>附：and or not 的含义</p><table><thead><tr><th>判断</th><th>含义</th></tr></thead><tbody><tr><td>True <strong>and</strong> True</td><td>需要两边同时满足才能返回 True</td></tr><tr><td>True <strong>or</strong> False</td><td>只要一边是 True 则返回 True</td></tr><tr><td><strong>not</strong> True</td><td>给出相反结果</td></tr></tbody></table><p>​有了这些工具，拿到最终的那个 True &#x2F; False 后，你就能再套用在 if-else 的结构里啦，将判断依据与判断后的流程联通在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = 1, 2</span><br><span class="line">if a &gt; b:</span><br><span class="line">    print(&quot;a 大于 b&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;a 不大于 b&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>if-elif-else</p><p>​还有比 if-else 更强大的结构。因为有时候我们还需要多判断一些情况，比如周一要干嘛，周二要干嘛，周三要干嘛等等，这并不是一个非黑即白的判断，而是多重判断连在一起的。 所以我们必然有更好的方式去判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">today = 4</span><br><span class="line">if today == 1:</span><br><span class="line">    print(&quot;周一&quot;)</span><br><span class="line">elif today == 2:</span><br><span class="line">    print(&quot;周二&quot;)</span><br><span class="line">elif today == 3:</span><br><span class="line">    print(&quot;周三&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;周一周二周三之外的一天&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Q：要判断多个数值区间该怎么写呢？</p><p>A：</p><p>for 和 while 循环</p>]]></content>
    
    
    <summary type="html">普通的笔记</summary>
    
    
    
    <category term="Python学习笔记" scheme="http://1921430580.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编程学习踩坑之路</title>
    <link href="http://1921430580.github.io/undefined/ccd12740/"/>
    <id>http://1921430580.github.io/undefined/ccd12740/</id>
    <published>2022-04-18T01:35:41.000Z</published>
    <updated>2022-04-21T08:14:32.916Z</updated>
    
    <content type="html"><![CDATA[<p>待更新</p>]]></content>
    
    
    <summary type="html">踩过的坑</summary>
    
    
    
    <category term="踩过的坑" scheme="http://1921430580.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
    <category term="踩过的坑" scheme="http://1921430580.github.io/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构学习笔记之</title>
    <link href="http://1921430580.github.io/undefined/37274411/"/>
    <id>http://1921430580.github.io/undefined/37274411/</id>
    <published>2022-04-18T01:27:35.000Z</published>
    <updated>2022-04-21T08:14:32.915Z</updated>
    
    <content type="html"><![CDATA[<p>待更新</p>]]></content>
    
    
    <summary type="html">一个简单的算法与数据结构学习笔记</summary>
    
    
    
    <category term="算法与数据结构学习笔记" scheme="http://1921430580.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记之初识c++</title>
    <link href="http://1921430580.github.io/undefined/84ec9e03/"/>
    <id>http://1921430580.github.io/undefined/84ec9e03/</id>
    <published>2022-04-18T00:29:06.000Z</published>
    <updated>2022-04-21T08:14:32.909Z</updated>
    
    <content type="html"><![CDATA[<p>想了想还是以c++prime为主吧。</p><h1 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h1><h2 id="1-1-编写一个简单的c-程序"><a href="#1-1-编写一个简单的c-程序" class="headerlink" title="1.1 编写一个简单的c++程序"></a>1.1 编写一个简单的c++程序</h2><h3 id="1-1-1-编译-运行程序"><a href="#1-1-1-编译-运行程序" class="headerlink" title="1.1.1 编译.运行程序"></a>1.1.1 编译.运行程序</h3><p>●由于计算机不能直接理解和运行C++源程序所以需要把人类读写的字符的排列变为计算机能理解的比特的排列。（即转换为0和1组成的代码）</p><p>●对源程序进行编译、链接，形成可执行文件</p><p>int类型是一种内置类型，即语言自身定义的类型</p><p>1.2 初识输入输出<br>        输入流和输出流而言，一个流就是一个字符序列。术语“流”的意思表示，随时间的推移，字符是顺序生成或消耗的。从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。</p><p>​标准库的四个标准输入输出流：cin、cout、cerr、clog。</p><p>​比如：cin &gt;&gt; x     #(cin是标准输入流，&gt;&gt;是输入运算符，&gt;&gt;x是变量)</p><p>​cin与键盘配合形成流，提取流过来的字符，并将其作为数值存放到变量x中。</p><p>cin:        istream类型的对象，标准输入( standard input )<br>cout:     ostream类型的对象，标准输出( standard output )<br>cerr:      ostream类型的对象，标准错误(standard error)<br>clog:     ostream类型的对象，用来输出程序运行时的一般信息</p><p>Q：关于引入标准库头文件</p><p>A：有两种方式，一种是尖括号一种是双引号，一般是指的他们的搜索路径不同，如果是尖括号是在系统指定目录寻找头文件，双引号（自己创建的头文件）是先到项目所在目录寻找头文件再到系统指定目录寻找头文件。</p><p>​cin可以跳过空格、制表符、换行符等空白字符</p><p>​cout 可以重定向（比如输出到文件），通过缓冲区。</p><p>​cerr 不可以重定向（只能输出到显示器），不通过缓冲区。cerr的作用是在一些特殊的紧急情况下还可以输出（比如调用栈用完了，没有出口的递归等）。缓冲区的目的是减少刷屏的次数，多个字符同时输出到显示器。<br>​endl 是操作符，用来结束当前行，将设备相关的缓冲区内容刷到设备中。在添加打印语句时，应保证一直刷新流，以防程序崩溃，输出还留在缓冲区内。</p><p>​前缀std::是标准库命名空间（不能重名）（namespace）</p><p>1.3 注释简介</p><p>​注释可以帮助读者理解程序。当修改代码时，不要忘记修改注释。</p><p>​C++ 有两种注释：<br>​单行注释：以双斜线（&#x2F;&#x2F;）开始，以换行符结束。<br>​界定符对注释（不能嵌套）：以 &#x2F;* 开始，以 *&#x2F; 结束。<br>​当界定符对注释跨越多行时，最好能显示指出其内部的程序行都属于多行注释的一部分，因此建议注释内的每行都以一个星号开头。<br>​在 VS 中使用快捷键注释多行时采用的是 &#x2F;&#x2F;，理解：因为要注释的代码中可能包含 *&#x2F; 字符，这种情况下使用界定符对注释会产生错误，所以采用单行注释方式。</p><h2 id="1-4-控制流循环与分支"><a href="#1-4-控制流循环与分支" class="headerlink" title="1.4 控制流循环与分支"></a>1.4 控制流循环与分支</h2><h3 id="1-4-1-while语句"><a href="#1-4-1-while语句" class="headerlink" title="1.4.1 while语句"></a>1.4.1 while语句</h3><p>​while 语句：反复执行一段代码，直到给定条件为假为止，直到条件为假。</p><p>​●语法形式</p><p>​while  (表达式)  语句: 可以是复合语句，其中必须含有改变条件表达式的语句。</p><p>​●  执行顺序</p><p>​先判断表达式的值，若为 true 时，执行语句。</p><p>​do-while语句</p><p>​●  do-while 语句的语法形式</p><p>​do   语句     &#x2F;&#x2F; 可以是复合语句，其中必须含有改变条件表达式值的语句。</p><p>​while (表达式)</p><p>​●  执行顺序</p><p>​先执行循环体语句，后判断条件。<br>​表达式为 true 时，继续执行循环体。</p><h3 id="1-4-2-for语句"><a href="#1-4-2-for语句" class="headerlink" title="1.4.2 for语句"></a>1.4.2 for语句</h3><p>​因为在循环条件中检测变量、在循环体中递增变量的模式使用非常频繁，所以 C++ 专门定义了第二种循环语句：for 语句，来简化这种模式。</p><p>●初始化语句、循环条件、循环体、表达式</p><img src="D:\blog\picture\for语句.png" style="zoom:75%;" /><p>● for语句的另一种形式：范围for语句：</p><pre><code>for  (声明：表达式)    语句</code></pre><h3 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3 读取数量不定的输入数据"></a>1.4.3 读取数量不定的输入数据</h3><p>​使用 while(cin&gt;&gt;value) 来读取数量不定的输入，循环会一直执行到遇到文件结束符或输入错误为止。windows的文件结束符是 Ctrl+Z 然后按 Enter<br>​在编译时，最好修改一个错误编译一次，或者最多修改了一小部分后重新编译。<br>​对于c++程序的缩进和格式，不存在唯一正确的风格，但是保持一致性是十分重要的。</p><p>1.4.4 if语句</p><p>●if (表达式) 语句</p><p>​例：if (x &gt; y) cout &lt;&lt; x;</p><p>●if (表达式) 语句1 else 语句2</p><p>​例：if (x &gt; y) cout &lt;&lt; x;</p><p>​else cout &lt;&lt; y;</p><p>●if (表达式1)语句1<br>  else if (表达式2) 语句2<br>  else if (表达式3) 语句3<br>            …<br>  else 语句 n</p><p>●嵌套的if结构</p><p>●  语法形式</p><p>if(   )</p><p>​if(   ) 语句 1</p><p>​else 语句 2</p><p>else</p><p>​if(   ) 语句 3</p><p>​else 语句 4</p><p>●  注意</p><p>​●  语句 1、2、3、4 可以是复合语句；</p><p>​●  每层的if 与 else 配对，或用 { } 来确定层次关系。</p><h2 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5 类简介"></a>1.5 类简介</h2><p>​C++中我们通过类（class）来定义自己的数据结构。<br>​一个类定义了一个类型，以及与其相关联的一组操作</p><p>1.5.2 初识成员函数<br>        成员函数是定义为类的一部分的函数，也被称为方法。<br>        通常以类对象的名义来调用成员函数：Item.isbn()。即使用点运算符(.)</p><p>​. 点运算符<br>​()调用运算符,里面可以放参数</p><p>问题<br>四个标准输入输出流是什么<br>cout 和 cerr 的两点区别<br>缓冲区有什么作用？可以通过什么刷新缓冲区<br>while(cin&gt;&gt;value)什么情况下会停止<br>windows 的文件结束符是什么</p><p>回答<br>cin、cout、cerr、clog<br>cout 可重定向，通过缓冲区；cerr 不可重定向，不通过缓冲区<br>缓冲区能减少刷屏的次数，每个 endl 都会刷新一次缓冲区<br>遇到文件结束符或输入错误<br>先 ctrl+z 后 enter</p>]]></content>
    
    
    <summary type="html">一个简单的笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优化日志</title>
    <link href="http://1921430580.github.io/undefined/341781e5/"/>
    <id>http://1921430580.github.io/undefined/341781e5/</id>
    <published>2022-04-17T09:14:51.000Z</published>
    <updated>2022-04-21T08:14:32.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022年4月11日"><a href="#2022年4月11日" class="headerlink" title="2022年4月11日"></a>2022年4月11日</h1><p>1、修改页头和页脚为透明</p><p>2、修改文章卡片和每个页面的透明度</p><p>3、优化头图由模糊变清晰的时间</p>]]></content>
    
    
    <summary type="html">记录一直以来的优化历程</summary>
    
    
    
    <category term="优化日志" scheme="http://1921430580.github.io/categories/%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="优化日志" scheme="http://1921430580.github.io/tags/%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>笔记本更换无线网卡</title>
    <link href="http://1921430580.github.io/undefined/925fa7fa/"/>
    <id>http://1921430580.github.io/undefined/925fa7fa/</id>
    <published>2022-04-17T07:52:51.000Z</published>
    <updated>2022-04-21T08:14:32.913Z</updated>
    
    <content type="html"><![CDATA[<p>​正好由于疫情原因封在家里不能出去，之前买了个IntelAX210无线网卡，顺便就给换了。原来的AC9462网卡实在太拉了</p><p>​AX210首先，直接上了一个新标准Wi-Fi6E，意味着更新、更强及更高性能。Wi-Fi6E较Wi-Fi6，新增了一个全新的6GHz超宽频段。有多宽呢？相当于平添110个信道，至高可支持160MHz频宽。虽然，速率上与5.8GHz相当，均为2402Mbps，但却空前纯净，几乎不存在任何干扰。在近距离传输上，6GHz频段显然更具前景。</p><p>​其次，AX210集成了更为强大的蓝牙5.2功能，而这一模块在Wi-Fi6上采用的则是蓝牙5.0标准。蓝牙5.2具有更高传输速率、更安全、更省电优势，在无线物联和无线影音表现上自然更胜一筹。</p><p>​wifi6E除了支持以往的2.4GHz与5GHz频段之外，还支持全新的6GHz频段，相较5GHz频段数量有着翻倍增加，让传输速度更快；同时将160MHz信道由2条增加至7条，同时将80MHz信道由6条增加至14条，解决连接多设备时互相干扰导致降速的问题</p><p>​WiFi 6相比WiFi 5，拥有更大带宽、更多连接终端、更低延迟等优势，主要是加入了BBS着色技术，降低信道干扰，反正比WiFi 5更好用就对了。配合WiFi 6路由器，绝对是美滋滋，体验非常好。未来的wifi6e也支持了，直接一步到位基本以后不需要换网卡了，如果网卡落后了那就是得直接换电脑了。</p><p>简单总结一下步骤：</p><p>1、洗手，2、摸金，3、拆后盖，4、断电源，5,、按几下开机键，6、拆网卡，7换网卡，8、复原，9、开机，10、安驱动</p><h1 id="1、洗手并摸一下金属物体"><a href="#1、洗手并摸一下金属物体" class="headerlink" title="1、洗手并摸一下金属物体"></a>1、洗手并摸一下金属物体</h1><p>​先洗手然后摸一下金属物体（比如门把手之类的）去除我们身上的静电。</p><p>作用是为了防止静电击穿而损坏笔记本的主板。</p><h1 id="2、拆后盖"><a href="#2、拆后盖" class="headerlink" title="2、拆后盖"></a>2、拆后盖</h1><p>用螺丝刀拆开即可，注意螺丝不要弄丢</p><h1 id="3、断电源"><a href="#3、断电源" class="headerlink" title="3、断电源"></a>3、断电源</h1><p>用手掰住电源插口的两个耳朵用力往外一拔就好</p><h1 id="4、按几下开机键"><a href="#4、按几下开机键" class="headerlink" title="4、按几下开机键"></a>4、按几下开机键</h1><p>用来去除笔记本的静电</p><h1 id="5、拆网卡"><a href="#5、拆网卡" class="headerlink" title="5、拆网卡"></a>5、拆网卡</h1><p>用螺丝刀拧开固定无线网卡的螺丝即可，拆掉的时候记得记清楚两根天线原来的安装位置，等会原样安回去。</p><h1 id="6、换网卡"><a href="#6、换网卡" class="headerlink" title="6、换网卡"></a>6、换网卡</h1><p>将购买的ax210网卡插进去然后拧上螺丝即可，记得天线安装顺序不要弄反。</p><h1 id="7、复原"><a href="#7、复原" class="headerlink" title="7、复原"></a>7、复原</h1><p>按拆机步骤反向来一遍即可</p><h1 id="8、检查"><a href="#8、检查" class="headerlink" title="8、检查"></a>8、检查</h1><p>打开设备管理器看看无线网卡是否成功安装，并且正确识别。</p><h1 id="9、安驱动"><a href="#9、安驱动" class="headerlink" title="9、安驱动"></a>9、安驱动</h1><p>进入Intel官网安装ax210的最新版驱动，不安驱动速度提升不大。</p><h1 id="10、网上冲浪！"><a href="#10、网上冲浪！" class="headerlink" title="10、网上冲浪！"></a>10、网上冲浪！</h1>]]></content>
    
    
    <summary type="html">简单的更换无线网卡</summary>
    
    
    
    <category term="电脑" scheme="http://1921430580.github.io/categories/%E7%94%B5%E8%84%91/"/>
    
    
    <category term="电脑" scheme="http://1921430580.github.io/tags/%E7%94%B5%E8%84%91/"/>
    
  </entry>
  
  <entry>
    <title>主题魔改踩坑之路</title>
    <link href="http://1921430580.github.io/undefined/51c3717f/"/>
    <id>http://1921430580.github.io/undefined/51c3717f/</id>
    <published>2022-04-17T06:58:21.000Z</published>
    <updated>2022-04-21T08:14:32.912Z</updated>
    
    <content type="html"><![CDATA[<p>测试</p>]]></content>
    
    
    <summary type="html">持续更新ing</summary>
    
    
    
    <category term="踩过的坑" scheme="http://1921430580.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
    <category term="踩过的坑" scheme="http://1921430580.github.io/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>c++学习笔记之预备知识</title>
    <link href="http://1921430580.github.io/undefined/4066/"/>
    <id>http://1921430580.github.io/undefined/4066/</id>
    <published>2022-04-15T08:46:51.000Z</published>
    <updated>2022-04-21T07:08:07.632Z</updated>
    
    <content type="html"><![CDATA[<p>​前言：本笔记通过观看b站的清华大学郑莉老师的c++课程结合学习c++语言程序设计和c++ primer 这两本书而总结的。</p><h1 id="一、计算机系统基本概念"><a href="#一、计算机系统基本概念" class="headerlink" title="一、计算机系统基本概念"></a>一、计算机系统基本概念</h1><h2 id="1、计算机硬件"><a href="#1、计算机硬件" class="headerlink" title="1、计算机硬件"></a>1、计算机硬件</h2><p>计算机硬件部分是由cpu、内存储器、外存储器、输入设备和输出设备五大部分组成的</p><h2 id="2、计算程序语言"><a href="#2、计算程序语言" class="headerlink" title="2、计算程序语言"></a>2、计算程序语言</h2><p>计算机解决问题是程序控制的；</p><p>程序就是操作步骤；</p><p>程序要使用语言来表达</p><h2 id="3、机器语言"><a href="#3、机器语言" class="headerlink" title="3、机器语言"></a>3、机器语言</h2><p>计算机能识别的是机器语言；</p><p>机器语言指令是由0和1编码的；</p><p>例如：加法指令可能是“0001”。</p><h2 id="4、计算软件"><a href="#4、计算软件" class="headerlink" title="4、计算软件"></a>4、计算软件</h2><p>是一系列按照特定顺序组织的计算机数据和指令的集合。一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件；</p><p>软件包括程序和文档。</p><h2 id="5、计算机程序"><a href="#5、计算机程序" class="headerlink" title="5、计算机程序"></a>5、计算机程序</h2><p>指令的序列；</p><p>描述解决问题的方法和数据。</p><h1 id="二、计算机语言和程序设计方法"><a href="#二、计算机语言和程序设计方法" class="headerlink" title="二、计算机语言和程序设计方法"></a>二、计算机语言和程序设计方法</h1><h2 id="最初的计算机语言——机器语言"><a href="#最初的计算机语言——机器语言" class="headerlink" title="最初的计算机语言——机器语言"></a>最初的计算机语言——机器语言</h2><p>由二进制代码构成</p><p>计算机硬件可以识别</p><p>可以表示简单的操作</p><p>例如：加法、减法、数据移动等等</p><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>将机器指令映射为助记符</p><p>如ADD、SUB、mov等；</p><p>抽象层次低，需要考虑机器细节。</p><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>关键字、语句容易理解；</p><p>有含义的数据命名和算式；</p><p>抽象层次较高；</p><p>例如，算式：a+b+c&#x2F;d</p><p>屏蔽了机器的细节；</p><p>例如，这样显示计算结果：cout&lt;&lt;a+b+c&#x2F;d</p><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><p>是高级语言</p><p>支持面向对象的观点和方法</p><p>将客观事物看做对象</p><p>对象间通过消息传送进行沟通</p><p>支持分类和抽象</p><h2 id="面向过程的程序设计方法："><a href="#面向过程的程序设计方法：" class="headerlink" title="面向过程的程序设计方法："></a>面向过程的程序设计方法：</h2><p>机器语言、汇编语言、高级语言都支持；</p><p>最初的目的：用于数学计算；</p><p>主要工作：设计求解问题的过程。</p><p>大型复杂的软件难以用面向过程的方式编写</p><h2 id="面向对象的程序设计方法："><a href="#面向对象的程序设计方法：" class="headerlink" title="面向对象的程序设计方法："></a>面向对象的程序设计方法：</h2><p>由面向对象的高级语言支持；</p><p>一个系统由对象构成；</p><p>对象之间通过消息进行通信。</p><h1 id="三、面向对象的基本概念"><a href="#三、面向对象的基本概念" class="headerlink" title="三、面向对象的基本概念"></a>三、面向对象的基本概念</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>一般意义上的对象：现实世界中实际存在的事物。</p><p>面向对象方法中的对象：程序中用来描述客观事物的实体。</p><h2 id="抽象与分类"><a href="#抽象与分类" class="headerlink" title="抽象与分类"></a>抽象与分类</h2><p>分类依据的原则——抽象；</p><p>l抽象出同一类对象的共同属性和行为形成类；</p><p>l类与对象是类型与实例的关系。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>隐蔽对象的内部细节；</p><p>对外形成一个边界；</p><p>只保留有限的对外接口；</p><p>使用方便、安全性好。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>意义在于软件复用；</p><p>改造、扩展已有类形成新的类。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同样的消息作用在不同对象上，可以引起不同的行为。</p><h1 id="四、程序的开发过程"><a href="#四、程序的开发过程" class="headerlink" title="四、程序的开发过程"></a>四、程序的开发过程</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="源程序："><a href="#源程序：" class="headerlink" title="源程序："></a>源程序：</h3><p>用源语言写的，有待翻译的程序；</p><h3 id="目标程序："><a href="#目标程序：" class="headerlink" title="目标程序："></a>目标程序：</h3><p>源程序通过翻译程序加工以后生成的机器语言程序；</p><h3 id="可执行程序："><a href="#可执行程序：" class="headerlink" title="可执行程序："></a>可执行程序：</h3><p>连接目标程序以及库中的某些文件，生成的一个可执行文件；</p><p>例如：Windows系统平台上的.EXE文件。</p><h2 id="三种不同类型的翻译程序"><a href="#三种不同类型的翻译程序" class="headerlink" title="三种不同类型的翻译程序"></a>三种不同类型的翻译程序</h2><h3 id="汇编程序："><a href="#汇编程序：" class="headerlink" title="汇编程序："></a>汇编程序：</h3><p>将汇编语言源程序翻译成目标程序；</p><h3 id="编译程序："><a href="#编译程序：" class="headerlink" title="编译程序："></a>编译程序：</h3><p>将高级语言源程序翻译成目标程序；</p><h3 id="解释程序："><a href="#解释程序：" class="headerlink" title="解释程序："></a>解释程序：</h3><p>将高级语言源程序翻译成机器指令，边翻译边执行。</p><p>C++程序的开发过程<br>算法与数据结构设计；源程序编辑；编译；连接；测试；调试。</p><h1 id="五、信息的表示与存储"><a href="#五、信息的表示与存储" class="headerlink" title="五、信息的表示与存储"></a>五、信息的表示与存储</h1><h2 id="计算机中的信息与存储单位"><a href="#计算机中的信息与存储单位" class="headerlink" title="计算机中的信息与存储单位"></a>计算机中的信息与存储单位</h2><h3 id="计算机的基本功能"><a href="#计算机的基本功能" class="headerlink" title="计算机的基本功能"></a>计算机的基本功能</h3><p>算术运算；逻辑运算。</p><h3 id="计算机中信息："><a href="#计算机中信息：" class="headerlink" title="计算机中信息："></a>计算机中信息：</h3><p>控制信息——指挥计算机操作；</p><p>数据信息——计算机程序加工的对象。</p><img src="D:\blog\picture\QQ图片20220415180845.png" style="zoom:50%;" /> <p>信息的存储单位<br>位(bit，b)：数据的最小单位，表示一位二进制信息；</p><p>字节(byte，B)：八位二进制数字组成(1byte&#x3D;8bit)；</p><p>千字节1KB&#x3D;1024B；</p><p>兆字节1MB&#x3D;1024K；</p><p>吉字节1GB&#x3D;1024M。</p><h3 id="计算机的数字系统"><a href="#计算机的数字系统" class="headerlink" title="计算机的数字系统"></a>计算机的数字系统</h3><p>二进制系统；</p><p>基本符号：0、1。</p><h3 id="程序中常用的数制："><a href="#程序中常用的数制：" class="headerlink" title="程序中常用的数制："></a>程序中常用的数制：</h3><table><thead><tr><th>进制</th><th>基数</th><th>进位原则</th><th>基本符号</th></tr></thead><tbody><tr><td>二进制</td><td>2</td><td>逢2进1</td><td>0,1</td></tr><tr><td>八进制</td><td>8</td><td>逢8进1</td><td>0,1,2,3,4,5,6,7</td></tr><tr><td>十进制</td><td>10</td><td>逢10进1</td><td>0,1,2,3,4,5,6,7,8,9</td></tr><tr><td>十六进制</td><td>16</td><td>逢16进1</td><td>0,1,2,3,4,5,6,7,8,9,A,B,D,E,F</td></tr></tbody></table><p>R 进制转换为十进制：各位数字与它的权相乘，其积相加.</p><p>十进制整数转换为R 进制整数：“除以R取余”法。</p><p>十进制小数→ R 进制小数：“乘以R取整”法。</p><p>八、十六进制的相互转换<br>1位八进制数相当于3位二进制数；</p><p>1位十六进制数相当于4位二进制数，例如：</p><p>(1011010.10)₂&#x3D;(001011010.100)₂&#x3D;(132.4)₈</p><p>(1011010.10)₂&#x3D;(01011010.1000)₂&#x3D;(5A.8)₁₆</p><p>(F7)₁₆＝(11110111)₂＝(11110111)₂</p><h1 id="数据在计算机中的编码表示"><a href="#数据在计算机中的编码表示" class="headerlink" title="数据在计算机中的编码表示"></a>数据在计算机中的编码表示</h1><h2 id="二进制数的编码表示"><a href="#二进制数的编码表示" class="headerlink" title="二进制数的编码表示"></a>二进制数的编码表示</h2><p>需要解决的问题：负数如何表示？</p><p>最容易想到的方案：</p><p>0：表示“+”号；</p><p>1：表示“-”号。</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>“符号──绝对值”表示的编码</p><p>原码的缺点：</p><p>零的表示不惟一：+0和-0有两种表示方式[+0]原&#x3D;000…0，[-0]原&#x3D;100…0</p><p>进行四则运算时，符号位须单独处理，运算规则复杂。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>符号位可作为数值参加运算；</p><p>减法运算可转换为加法运算；</p><p>n0的表示唯一。</p><h4 id="补码的原理"><a href="#补码的原理" class="headerlink" title="补码的原理"></a>补码的原理</h4><p>模数：</p><p>位二进制整数的模数为2n；</p><p>位二进制小数的模数为2。</p><p>补数：</p><p>一个数减去另一个数（加一个负数），等于第一个数加第二个数的补数，例（时钟指针）：8+(-2)&#x3D;8+10(mod12)&#x3D;6；</p><p>一个二进制负数可用其模数与真值做加法(模减去该数的绝对值)求得其补码，例（时钟指针）：-2+12&#x3D;10。</p><h4 id="补码的计算"><a href="#补码的计算" class="headerlink" title="补码的计算"></a>补码的计算</h4><p>借助于“反码”作为中间码；</p><p>负数的反码与原码有如下关系：</p><p>符号位不变(仍用1表示)，其余各位取反(0变1，1变0)，</p><p>正数的反码与原码表示相同，正数的补码与原码相同；</p><p>反码只是求补码时的中间码；</p><p>负数的补码由该数反码的末位加1求得。</p><p>对补码再求补即得到原码。</p><h4 id="补码的优点："><a href="#补码的优点：" class="headerlink" title="补码的优点："></a>补码的优点：</h4><p>0的表示唯一；</p><p>符号位可作为数值参加运算；</p><p>补码运算的结果仍为补码。</p><p>实数的浮点表示计算机中通常采用浮点方式表示小数；</p><p>实数N用浮点形式可表示为：N&#x3D;M×2E</p><p>E：2的幂，N：阶码；</p><p>M：N的尾数。</p><p>字符在计算机中的表示<br>字符在计算机中是通过编码表示的；</p><p>例如：ASCII码是一种常用的西文字符编码：用7位二进制数表示一个字符，最多可以表示27&#x3D;128个字符；《GB18030-2005信息技术中文编码字符集》是中国国家标准。</p>]]></content>
    
    
    <summary type="html">一个简单的笔记</summary>
    
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://1921430580.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="http://1921430580.github.io/undefined/9903/"/>
    <id>http://1921430580.github.io/undefined/9903/</id>
    <published>2022-04-12T13:38:51.000Z</published>
    <updated>2022-04-17T06:47:04.333Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈哈</p>]]></content>
    
    
    <summary type="html">毫无意义</summary>
    
    
    
    <category term="随笔" scheme="http://1921430580.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="c++学习笔记" scheme="http://1921430580.github.io/tags/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://1921430580.github.io/undefined/16107/"/>
    <id>http://1921430580.github.io/undefined/16107/</id>
    <published>2022-04-11T08:46:51.000Z</published>
    <updated>2022-04-17T06:48:43.588Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="随笔" scheme="http://1921430580.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
